Subject: [PATCH] Merge branch 'refs/heads/jdk21.0.1' into jdk-21.0.3+9
jdk21u_android
jdk21u_android
---
Index: make/autoconf/flags-cflags.m4
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/make/autoconf/flags-cflags.m4 b/make/autoconf/flags-cflags.m4
--- a/make/autoconf/flags-cflags.m4	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/make/autoconf/flags-cflags.m4	(revision 66ffa08a1eb301a088b8f50882b0c882ccbf179f)
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2011, 2023, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2011, 2024, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -117,6 +117,11 @@
       FLAGS_COMPILER_CHECK_ARGUMENTS(ARGUMENT: [${DEBUG_PREFIX_CFLAGS}],
         IF_FALSE: [
             DEBUG_PREFIX_CFLAGS=
+        ],
+        IF_TRUE: [
+            # Add debug prefix map gcc system include paths, as they cause
+            # non-deterministic debug paths depending on gcc path location.
+            DEBUG_PREFIX_MAP_GCC_INCLUDE_PATHS
         ]
       )
     fi
@@ -158,6 +163,55 @@
   AC_SUBST(ASFLAGS_DEBUG_SYMBOLS)
 ])
 
+# gcc will embed the full system include paths in the debug info
+# resulting in non-deterministic debug symbol files and thus
+# non-reproducible native libraries if gcc includes are located
+# in different paths.
+# Add -fdebug-prefix-map'ings for root and gcc include paths,
+# pointing to a common set of folders so that the binaries are deterministic:
+#  root include : /usr/include
+#  gcc include  : /usr/local/gcc_include
+#  g++ include  : /usr/local/gxx_include
+AC_DEFUN([DEBUG_PREFIX_MAP_GCC_INCLUDE_PATHS],
+[
+    # Determine gcc system include paths.
+    # Assume default roots to start with:
+    GCC_ROOT_INCLUDE="/usr/include"
+
+    # Determine is sysroot or devkit specified?
+    if test "x$SYSROOT" != "x"; then
+      GCC_ROOT_INCLUDE="${SYSROOT%/}/usr/include"
+    fi
+
+    # Add root include mapping => /usr/include
+    GCC_INCLUDE_DEBUG_MAP_FLAGS="-fdebug-prefix-map=${GCC_ROOT_INCLUDE}/=/usr/include/"
+
+    # Add gcc system include mapping => /usr/local/gcc_include
+    #   Find location of stddef.h using build C compiler
+    GCC_SYSTEM_INCLUDE=`$ECHO "#include <stddef.h>" | \
+                        $CC $CFLAGS -v -E - 2>&1 | \
+                        $GREP stddef | $TAIL -1 | $TR -s " " | $CUT -d'"' -f2`
+    if test "x$GCC_SYSTEM_INCLUDE" != "x"; then
+      GCC_SYSTEM_INCLUDE=`$DIRNAME $GCC_SYSTEM_INCLUDE`
+      GCC_INCLUDE_DEBUG_MAP_FLAGS="$GCC_INCLUDE_DEBUG_MAP_FLAGS \
+          -fdebug-prefix-map=${GCC_SYSTEM_INCLUDE}/=/usr/local/gcc_include/"
+    fi
+
+    # Add g++ system include mapping => /usr/local/gxx_include
+    #   Find location of cstddef using build C++ compiler
+    GXX_SYSTEM_INCLUDE=`$ECHO "#include <cstddef>" | \
+                        $CXX $CXXFLAGS -v -E -x c++ - 2>&1 | \
+                        $GREP cstddef | $TAIL -1 | $TR -s " " | $CUT -d'"' -f2`
+    if test "x$GXX_SYSTEM_INCLUDE" != "x"; then
+      GXX_SYSTEM_INCLUDE=`$DIRNAME $GXX_SYSTEM_INCLUDE`
+      GCC_INCLUDE_DEBUG_MAP_FLAGS="$GCC_INCLUDE_DEBUG_MAP_FLAGS \
+          -fdebug-prefix-map=${GXX_SYSTEM_INCLUDE}/=/usr/local/gxx_include/"
+    fi
+
+    # Add to debug prefix cflags
+    DEBUG_PREFIX_CFLAGS="$DEBUG_PREFIX_CFLAGS $GCC_INCLUDE_DEBUG_MAP_FLAGS"
+])
+
 AC_DEFUN([FLAGS_SETUP_WARNINGS],
 [
   # Set default value.
@@ -425,8 +479,9 @@
 [
   #### OS DEFINES, these should be independent on toolchain
   if test "x$OPENJDK_TARGET_OS" = xlinux; then
-    CFLAGS_OS_DEF_JVM="-DLINUX"
-    CFLAGS_OS_DEF_JDK="-D_GNU_SOURCE -D_REENTRANT -D_LARGEFILE64_SOURCE"
+    CFLAGS_OS_DEF_JVM="-DLINUX -D_FILE_OFFSET_BITS=64"
+    # CFLAGS_OS_DEF_JDK="-D_GNU_SOURCE -D_REENTRANT -D_LARGEFILE64_SOURCE"
+    CFLAGS_OS_DEF_JDK="-D_GNU_SOURCE -D_REENTRANT -D_LARGEFILE64_SOURCE -D__USE_BSD"
   elif test "x$OPENJDK_TARGET_OS" = xmacosx; then
     CFLAGS_OS_DEF_JVM="-D_ALLBSD_SOURCE -D_DARWIN_C_SOURCE -D_XOPEN_SOURCE"
     CFLAGS_OS_DEF_JDK="-D_ALLBSD_SOURCE -D_DARWIN_UNLIMITED_SELECT"
@@ -816,6 +871,7 @@
             REPRODUCIBLE_CFLAGS=
         ]
     )
+    AC_SUBST(REPRODUCIBLE_CFLAGS)
   fi
 
   # Prevent the __FILE__ macro from generating absolute paths into the built
@@ -849,6 +905,22 @@
               FILE_MACRO_CFLAGS=
           ]
       )
+      if test "x$FILE_MACRO_CFLAGS" != x; then
+        # Add -pathmap for all VS system include paths using Windows
+        # full Long path name that is generated by the compiler
+        # Not enabled under WSL as there is no easy way to obtain the
+        # Windows full long paths, thus reproducible WSL builds will
+        # depend on building with the same VS toolchain install location.
+        if test "x$OPENJDK_BUILD_OS_ENV" != "xwindows.wsl1" && test "x$OPENJDK_BUILD_OS_ENV" != "xwindows.wsl2"; then
+          for ipath in ${$3SYSROOT_CFLAGS}; do
+              if test "x${ipath:0:2}" == "x-I"; then
+                  ipath_path=${ipath#"-I"}
+                  UTIL_FIXUP_WIN_LONG_PATH(ipath_path)
+                  FILE_MACRO_CFLAGS="$FILE_MACRO_CFLAGS -pathmap:\"$ipath_path\"=vsi"
+              fi
+          done
+        fi
+      fi
     fi
 
     AC_MSG_CHECKING([how to prevent absolute paths in output])
Index: make/autoconf/flags-ldflags.m4
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/make/autoconf/flags-ldflags.m4 b/make/autoconf/flags-ldflags.m4
--- a/make/autoconf/flags-ldflags.m4	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/make/autoconf/flags-ldflags.m4	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -186,7 +186,9 @@
        test "x${OPENJDK_$1_CPU}" = xmips64el; then
       $1_CPU_LDFLAGS="${$1_CPU_LDFLAGS} -Wl,--hash-style=sysv"
     else
-      $1_CPU_LDFLAGS="${$1_CPU_LDFLAGS} -Wl,--hash-style=gnu"
+      # Android 5.x does not support GNU hash style
+      # gnu
+      $1_CPU_LDFLAGS="${$1_CPU_LDFLAGS} -Wl,--hash-style=sysv"
     fi
 
   elif test "x$TOOLCHAIN_TYPE" = xmicrosoft; then
Index: make/autoconf/lib-freetype.m4
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/make/autoconf/lib-freetype.m4 b/make/autoconf/lib-freetype.m4
--- a/make/autoconf/lib-freetype.m4	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/make/autoconf/lib-freetype.m4	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -103,7 +103,8 @@
   FREETYPE_TO_USE=bundled
   if test "x$OPENJDK_TARGET_OS" != "xwindows" && \
       test "x$OPENJDK_TARGET_OS" != "xmacosx" && \
-      test "x$OPENJDK_TARGET_OS" != "xaix"; then
+      test "x$OPENJDK_TARGET_OS" != "xaix" && \
+      test "x$OPENJDK_TARGET_OS" != "xandroid"; then
     FREETYPE_TO_USE=system
   fi
   if test "x$with_freetype" != "x" ; then
Index: make/autoconf/libraries.m4
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/make/autoconf/libraries.m4 b/make/autoconf/libraries.m4
--- a/make/autoconf/libraries.m4	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/make/autoconf/libraries.m4	(revision 66ffa08a1eb301a088b8f50882b0c882ccbf179f)
@@ -42,8 +42,8 @@
 AC_DEFUN_ONCE([LIB_DETERMINE_DEPENDENCIES],
 [
   # Check if X11 is needed
-  if test "x$OPENJDK_TARGET_OS" = xwindows || test "x$OPENJDK_TARGET_OS" = xmacosx; then
-    # No X11 support on windows or macosx
+  if test "x$OPENJDK_TARGET_OS" = xwindows || test "x$OPENJDK_TARGET_OS" = xmacosx || test "x$OPENJDK_TARGET_OS" = xandroid; then
+    # No X11 support on windows, macosx or android
     NEEDS_LIB_X11=false
   else
     # All other instances need X11, even if building headless only, libawt still
@@ -52,8 +52,8 @@
   fi
 
   # Check if fontconfig is needed
-  if test "x$OPENJDK_TARGET_OS" = xwindows || test "x$OPENJDK_TARGET_OS" = xmacosx; then
-    # No fontconfig support on windows or macosx
+  if test "x$OPENJDK_TARGET_OS" = xwindows || test "x$OPENJDK_TARGET_OS" = xmacosx || test "x$OPENJDK_TARGET_OS" = xandroid; then
+    # No fontconfig support on windows, macosx or android
     NEEDS_LIB_FONTCONFIG=false
   else
     # All other instances need fontconfig, even if building headless only,
@@ -108,12 +108,6 @@
       BASIC_JVM_LIBS_$1="$BASIC_JVM_LIBS_$1 -latomic"
     fi
   fi
-
-  # Because RISC-V only has word-sized atomics, it requires libatomic where
-  # other common architectures do not, so link libatomic by default.
-  if test "x$OPENJDK_$1_OS" = xlinux && test "x$OPENJDK_$1_CPU" = xriscv64; then
-    BASIC_JVM_LIBS_$1="$BASIC_JVM_LIBS_$1 -latomic"
-  fi
 ])
 
 ################################################################################
Index: make/autoconf/platform.m4
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/make/autoconf/platform.m4 b/make/autoconf/platform.m4
--- a/make/autoconf/platform.m4	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/make/autoconf/platform.m4	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -202,6 +202,10 @@
       VAR_OS=linux
       VAR_OS_TYPE=unix
       ;;
+    *android*)
+      VAR_OS=linux
+      VAR_OS_TYPE=unix
+      ;;
     *darwin*)
       VAR_OS=macosx
       VAR_OS_TYPE=unix
Index: make/autoconf/toolchain.m4
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/make/autoconf/toolchain.m4 b/make/autoconf/toolchain.m4
--- a/make/autoconf/toolchain.m4	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/make/autoconf/toolchain.m4	(revision 66ffa08a1eb301a088b8f50882b0c882ccbf179f)
@@ -1,5 +1,5 @@
 #
-# Copyright (c) 2011, 2023, Oracle and/or its affiliates. All rights reserved.
+# Copyright (c) 2011, 2024, Oracle and/or its affiliates. All rights reserved.
 # DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 #
 # This code is free software; you can redistribute it and/or modify it
@@ -389,6 +389,10 @@
   # This is necessary since AC_PROG_CC defaults CFLAGS to "-g -O2"
   CFLAGS="$ORG_CFLAGS"
   CXXFLAGS="$ORG_CXXFLAGS"
+
+  # filter out some unwanted additions autoconf may add to CXX; we saw this on macOS with autoconf 2.72
+  UTIL_GET_NON_MATCHING_VALUES(cxx_filtered, $CXX, -std=c++11 -std=gnu++11)
+  CXX="$cxx_filtered"
 ])
 
 # Check if a compiler is of the toolchain type we expect, and save the version
@@ -944,11 +948,14 @@
 
     PATH="$OLDPATH"
 
-    TOOLCHAIN_EXTRACT_COMPILER_VERSION(BUILD_CC, [BuildC])
-    TOOLCHAIN_EXTRACT_COMPILER_VERSION(BUILD_CXX, [BuildC++])
-    TOOLCHAIN_PREPARE_FOR_VERSION_COMPARISONS([BUILD_], [OPENJDK_BUILD_], [build ])
-    TOOLCHAIN_EXTRACT_LD_VERSION(BUILD_LD, [build linker])
-    TOOLCHAIN_PREPARE_FOR_LD_VERSION_COMPARISONS([BUILD_], [OPENJDK_BUILD_])
+    # xandroid
+    if test "x$OPENJDK_BUILD_OS" != "xlinux"; then
+      TOOLCHAIN_EXTRACT_COMPILER_VERSION(BUILD_CC, [BuildC])
+      TOOLCHAIN_EXTRACT_COMPILER_VERSION(BUILD_CXX, [BuildC++])
+      TOOLCHAIN_PREPARE_FOR_VERSION_COMPARISONS([BUILD_], [OPENJDK_BUILD_], [build ])
+      TOOLCHAIN_EXTRACT_LD_VERSION(BUILD_LD, [build linker])
+      TOOLCHAIN_PREPARE_FOR_LD_VERSION_COMPARISONS([BUILD_], [OPENJDK_BUILD_])
+    fi
   else
     # If we are not cross compiling, use the normal target compilers for
     # building the build platform executables.
Index: make/common/JdkNativeCompilation.gmk
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/make/common/JdkNativeCompilation.gmk b/make/common/JdkNativeCompilation.gmk
--- a/make/common/JdkNativeCompilation.gmk	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/make/common/JdkNativeCompilation.gmk	(revision 66ffa08a1eb301a088b8f50882b0c882ccbf179f)
@@ -41,6 +41,12 @@
       $(TOPDIR)/src/$(strip $1)/$(OPENJDK_TARGET_OS_TYPE)/native/lib$(strip $2) \
       $(TOPDIR)/src/$(strip $1)/share/native/lib$(strip $2)))
 
+ifeq ($(OPENJDK_TARGET_OS), android)
+  FindSrcDirsForLib += \
+    $(call uniq, $(wildcard \
+        $(TOPDIR)/src/$(strip $1)/linux/native/lib$(strip $2)))
+endif
+
 FindSrcDirsForComponent += \
   $(call uniq, $(wildcard \
       $(TOPDIR)/src/$(strip $1)/$(OPENJDK_TARGET_OS)/native/$(strip $2) \
@@ -98,7 +104,7 @@
 
 JDK_RCFLAGS=$(RCFLAGS) \
     -D"JDK_VERSION_STRING=$(VERSION_STRING)" \
-    -D"JDK_COMPANY=$(COMPANY_NAME)" \
+    -D"JDK_COMPANY=$(JDK_RC_COMPANY_NAME)" \
     -D"JDK_VER=$(VERSION_NUMBER_FOUR_POSITIONS)" \
     -D"JDK_COPYRIGHT=Copyright \xA9 $(COPYRIGHT_YEAR)" \
     -D"JDK_NAME=$(JDK_RC_NAME) $(VERSION_SHORT)" \
Index: make/common/Modules.gmk
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/make/common/Modules.gmk b/make/common/Modules.gmk
--- a/make/common/Modules.gmk	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/make/common/Modules.gmk	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -83,6 +83,10 @@
 TOP_SRC_DIRS += \
     $(TOPDIR)/src \
     #
+ifeq ($(OPENJDK_TARGET_OS), android)
+  SRC_SUBDIRS += linux/classes
+endif
+
 
 SRC_SUBDIRS += $(OPENJDK_TARGET_OS)/classes
 ifneq ($(OPENJDK_TARGET_OS), $(OPENJDK_TARGET_OS_TYPE))
Index: make/common/Utils.gmk
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/make/common/Utils.gmk b/make/common/Utils.gmk
--- a/make/common/Utils.gmk	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/make/common/Utils.gmk	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -346,6 +346,12 @@
 isTargetOs = \
   $(strip $(if $(filter $(OPENJDK_TARGET_OS), $1), true, false))
 
+ifeq ($(call isTargetOs, android), true)
+  # PATCH: Since Android is Linux, so Linux specific things are also built for Android.
+  isTargetOs = \
+    $(strip $(if $(filter $(OPENJDK_TARGET_OS), $1), true, $(if $(filter linux, $1), true, false)))
+endif
+
 isTargetOsType = \
   $(strip $(if $(filter $(OPENJDK_TARGET_OS_TYPE), $1), true, false))
 
Index: make/hotspot/lib/JvmMapfile.gmk
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/make/hotspot/lib/JvmMapfile.gmk b/make/hotspot/lib/JvmMapfile.gmk
--- a/make/hotspot/lib/JvmMapfile.gmk	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/make/hotspot/lib/JvmMapfile.gmk	(revision 66ffa08a1eb301a088b8f50882b0c882ccbf179f)
@@ -52,8 +52,8 @@
 # Create a dynamic list of symbols from the built object files. This is highly
 # platform dependent.
 
-ifeq ($(call isTargetOs, linux), true)
-  DUMP_SYMBOLS_CMD := $(NM) --defined-only *$(OBJ_SUFFIX)
+ifeq ($(call isTargetOs, android linux), true)
+  DUMP_SYMBOLS_CMD := $(NM) $(NMFLAGS) --defined-only *$(OBJ_SUFFIX)
   ifneq ($(FILTER_SYMBOLS_PATTERN), )
     FILTER_SYMBOLS_PATTERN := $(FILTER_SYMBOLS_PATTERN)|
   endif
@@ -67,7 +67,7 @@
 else ifeq ($(call isTargetOs, macosx), true)
   # nm on macosx prints out "warning: nm: no name list" to stderr for
   # files without symbols. Hide this, even at the expense of hiding real errors.
-  DUMP_SYMBOLS_CMD := $(NM) -Uj *$(OBJ_SUFFIX) 2> /dev/null
+  DUMP_SYMBOLS_CMD := $(NM) $(NMFLAGS) -Uj *$(OBJ_SUFFIX) 2> /dev/null
   ifneq ($(FILTER_SYMBOLS_PATTERN), )
     FILTER_SYMBOLS_PATTERN := $(FILTER_SYMBOLS_PATTERN)|
   endif
@@ -89,7 +89,7 @@
   # which may be installed under /opt/freeware/bin. So better use an absolute path here!
   # NM=/usr/bin/nm
 
-  DUMP_SYMBOLS_CMD := $(NM) -X64 -B -C *$(OBJ_SUFFIX)
+  DUMP_SYMBOLS_CMD := $(NM) $(NMFLAGS) -B -C *$(OBJ_SUFFIX)
   FILTER_SYMBOLS_AWK_SCRIPT := \
       '{ \
         if (($$2="d" || $$2="D") && ($$3 ~ /^__vft/ || $$3 ~ /^gHotSpotVM/)) print $$3; \
Index: make/hotspot/lib/JvmOverrideFiles.gmk
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/make/hotspot/lib/JvmOverrideFiles.gmk b/make/hotspot/lib/JvmOverrideFiles.gmk
--- a/make/hotspot/lib/JvmOverrideFiles.gmk	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/make/hotspot/lib/JvmOverrideFiles.gmk	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -62,7 +62,8 @@
 	#
   endif
 
-  ifeq ($(call isTargetCpu, x86), true)
+  #ifeq ($(call isTargetCpu, x86), true)
+  ifeq (false, true)
     # Performance measurements show that by compiling GC related code, we could
     # significantly reduce the GC pause time on 32 bit Linux/Unix platforms by
     # compiling without the PIC flag (-fPIC on linux).
Index: make/modules/java.base/lib/CoreLibraries.gmk
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/make/modules/java.base/lib/CoreLibraries.gmk b/make/modules/java.base/lib/CoreLibraries.gmk
--- a/make/modules/java.base/lib/CoreLibraries.gmk	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/make/modules/java.base/lib/CoreLibraries.gmk	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -78,6 +78,10 @@
 
 TARGETS += $(BUILD_LIBJAVA)
 
+ifeq ($(OPENJDK_TARGET_OS), linux)
+  $(BUILD_LIBJAVA): $(BUILD_LIBTINYICONV)
+endif
+
 $(BUILD_LIBJAVA): $(BUILD_LIBVERIFY)
 
 
Index: make/modules/java.desktop/Lib.gmk
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/make/modules/java.desktop/Lib.gmk b/make/modules/java.desktop/Lib.gmk
--- a/make/modules/java.desktop/Lib.gmk	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/make/modules/java.desktop/Lib.gmk	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -76,7 +76,7 @@
 
   $(BUILD_LIBJSOUND): $(call FindLib, java.base, java)
 
-  TARGETS += $(BUILD_LIBJSOUND)
+  # TARGETS += $(BUILD_LIBJSOUND)
 
 endif
 
Index: make/modules/java.desktop/lib/Awt2dLibraries.gmk
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/make/modules/java.desktop/lib/Awt2dLibraries.gmk b/make/modules/java.desktop/lib/Awt2dLibraries.gmk
--- a/make/modules/java.desktop/lib/Awt2dLibraries.gmk	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/make/modules/java.desktop/lib/Awt2dLibraries.gmk	(revision 66ffa08a1eb301a088b8f50882b0c882ccbf179f)
@@ -423,7 +423,6 @@
     LIBFREETYPE_LIBS := -lfreetype
   endif
 
-  # gcc_ftobjs.c := maybe-uninitialized required for GCC 7 builds.
   $(eval $(call SetupJdkLibrary, BUILD_LIBFREETYPE, \
       NAME := freetype, \
       OPTIMIZATION := HIGHEST, \
@@ -432,7 +431,6 @@
       EXTRA_HEADER_DIRS := $(BUILD_LIBFREETYPE_HEADER_DIRS), \
       DISABLED_WARNINGS_microsoft := 4267 4244 4996, \
       DISABLED_WARNINGS_gcc := dangling-pointer stringop-overflow, \
-      DISABLED_WARNINGS_gcc_ftobjs.c := maybe-uninitialized, \
       LDFLAGS := $(LDFLAGS_JDKLIB) \
           $(call SET_SHARED_LIBRARY_ORIGIN), \
   ))
@@ -469,11 +467,18 @@
    # hb-ft.cc is not presently needed, and requires freetype 2.4.2 or later.
    LIBFONTMANAGER_EXCLUDE_FILES += libharfbuzz/hb-ft.cc
 
+   # list of disabled warnings and the compilers for which it was specifically added.
+   # array-bounds         -> GCC 12 on Alpine Linux
+   # parentheses          -> GCC 6
+   # range-loop-analysis  -> clang on Xcode12
+
    HARFBUZZ_DISABLED_WARNINGS_gcc := missing-field-initializers strict-aliasing \
-       unused-result array-bounds
+       unused-result array-bounds parentheses
    # noexcept-type required for GCC 7 builds. Not required for GCC 8+.
    # expansion-to-defined required for GCC 9 builds. Not required for GCC 10+.
-   HARFBUZZ_DISABLED_WARNINGS_CXX_gcc := class-memaccess noexcept-type expansion-to-defined dangling-reference
+   # maybe-uninitialized required for GCC 8 builds. Not required for GCC 9+.
+   HARFBUZZ_DISABLED_WARNINGS_CXX_gcc := class-memaccess noexcept-type \
+       expansion-to-defined dangling-reference maybe-uninitialized
    HARFBUZZ_DISABLED_WARNINGS_clang := missing-field-initializers range-loop-analysis
    HARFBUZZ_DISABLED_WARNINGS_microsoft := 4267 4244
 
@@ -546,7 +551,7 @@
     LDFLAGS_unix := -L$(INSTALL_LIBRARIES_HERE), \
     LDFLAGS_aix := -Wl$(COMMA)-berok, \
     LIBS := $(BUILD_LIBFONTMANAGER_FONTLIB), \
-    LIBS_unix := -lawt -ljava -ljvm $(LIBM) $(LIBCXX), \
+    LIBS_unix := -lawt -lawt_headless -ljava -ljvm $(LIBM) $(LIBCXX), \
     LIBS_macosx := -lawt_lwawt -framework CoreText -framework CoreFoundation -framework CoreGraphics, \
     LIBS_windows := $(WIN_JAVA_LIB) advapi32.lib user32.lib gdi32.lib \
         $(WIN_AWT_LIB), \
@@ -799,7 +804,7 @@
       LIBS_aix := -liconv, \
   ))
 
-  TARGETS += $(BUILD_LIBSPLASHSCREEN)
+  # TARGETS += $(BUILD_LIBSPLASHSCREEN)
 
   ifeq ($(call isTargetOs, macosx), true)
     $(BUILD_LIBSPLASHSCREEN): $(call FindLib, $(MODULE), osxapp)
Index: make/modules/java.instrument/Lib.gmk
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/make/modules/java.instrument/Lib.gmk b/make/modules/java.instrument/Lib.gmk
--- a/make/modules/java.instrument/Lib.gmk	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/make/modules/java.instrument/Lib.gmk	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -36,9 +36,11 @@
 $(eval $(call SetupJdkLibrary, BUILD_LIBINSTRUMENT, \
     NAME := instrument, \
     OPTIMIZATION := LOW, \
+    EXTRA_SRC := java.base:libtinyiconv, \
     CFLAGS := $(CFLAGS_JDKLIB) $(LIBINSTRUMENT_CFLAGS), \
     CFLAGS_debug := -DJPLIS_LOGGING, \
     CFLAGS_release := -DNO_JPLIS_LOGGING, \
+    CXXFLAGS := $(CXXFLAGS_JDKLIB), \
     EXTRA_HEADER_DIRS := java.base:libjli, \
     LDFLAGS := $(LDFLAGS_JDKLIB) \
         $(call SET_SHARED_LIBRARY_ORIGIN) \
Index: make/modules/jdk.hotspot.agent/Lib.gmk
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/make/modules/jdk.hotspot.agent/Lib.gmk b/make/modules/jdk.hotspot.agent/Lib.gmk
--- a/make/modules/jdk.hotspot.agent/Lib.gmk	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/make/modules/jdk.hotspot.agent/Lib.gmk	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -76,6 +76,6 @@
     LIBS_windows := dbgeng.lib $(WIN_JAVA_LIB), \
 ))
 
-TARGETS += $(BUILD_LIBSA)
+# TARGETS += $(BUILD_LIBSA)
 
 ################################################################################
Index: make/modules/jdk.jdwp.agent/Lib.gmk
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/make/modules/jdk.jdwp.agent/Lib.gmk b/make/modules/jdk.jdwp.agent/Lib.gmk
--- a/make/modules/jdk.jdwp.agent/Lib.gmk	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/make/modules/jdk.jdwp.agent/Lib.gmk	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -53,6 +53,7 @@
     NAME := jdwp, \
     OPTIMIZATION := LOW, \
     CFLAGS := $(CFLAGS_JDKLIB) -DJDWP_LOGGING, \
+    CXXFLAGS := $(CXXFLAGS_JDKLIB), \
     DISABLED_WARNINGS_gcc_SDE.c := unused-function, \
     DISABLED_WARNINGS_clang_error_messages.c := format-nonliteral, \
     DISABLED_WARNINGS_clang_EventRequestImpl.c := self-assign, \
@@ -61,6 +62,7 @@
     EXTRA_HEADER_DIRS := \
       include \
       libjdwp/export, \
+    EXTRA_SRC := java.base:libtinyiconv, \
     LDFLAGS := $(LDFLAGS_JDKLIB) \
         $(call SET_SHARED_LIBRARY_ORIGIN), \
     LIBS := $(JDKLIB_LIBS), \
Index: make/modules/jdk.net/Lib.gmk
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/make/modules/jdk.net/Lib.gmk b/make/modules/jdk.net/Lib.gmk
--- a/make/modules/jdk.net/Lib.gmk	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/make/modules/jdk.net/Lib.gmk	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -27,7 +27,7 @@
 
 ################################################################################
 
-ifeq ($(call isTargetOs, linux macosx windows aix), true)
+ifeq ($(call isTargetOs, linux macosx windows aix android), true)
 
   $(eval $(call SetupJdkLibrary, BUILD_LIBEXTNET, \
       NAME := extnet, \
Index: src/hotspot/cpu/arm/icache_arm.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/hotspot/cpu/arm/icache_arm.cpp b/src/hotspot/cpu/arm/icache_arm.cpp
--- a/src/hotspot/cpu/arm/icache_arm.cpp	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/src/hotspot/cpu/arm/icache_arm.cpp	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -31,7 +31,7 @@
 
 
 static int icache_flush(address addr, int lines, int magic) {
-  __builtin___clear_cache(addr, addr + (lines << ICache::log2_line_size));
+  __builtin___clear_cache((char*) addr, (char*) (addr + (lines << ICache::log2_line_size)));
   return magic;
 }
 
Index: src/hotspot/os/linux/gc/x/xNUMA_linux.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/hotspot/os/linux/gc/x/xNUMA_linux.cpp b/src/hotspot/os/linux/gc/x/xNUMA_linux.cpp
--- a/src/hotspot/os/linux/gc/x/xNUMA_linux.cpp	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/src/hotspot/os/linux/gc/x/xNUMA_linux.cpp	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -31,41 +31,17 @@
 #include "utilities/debug.hpp"
 
 void XNUMA::pd_initialize() {
-  _enabled = UseNUMA;
+  _enabled = false;
 }
 
 uint32_t XNUMA::count() {
-  if (!_enabled) {
-    // NUMA support not enabled
-    return 1;
-  }
+  return 1;
+}
 
-  return os::Linux::numa_max_node() + 1;
-}
-
 uint32_t XNUMA::id() {
-  if (!_enabled) {
-    // NUMA support not enabled
-    return 0;
-  }
+  return 0;
+}
 
-  return os::Linux::get_node_by_cpu(XCPU::id());
-}
-
 uint32_t XNUMA::memory_id(uintptr_t addr) {
-  if (!_enabled) {
-    // NUMA support not enabled, assume everything belongs to node zero
-    return 0;
-  }
-
-  uint32_t id = (uint32_t)-1;
-
-  if (XSyscall::get_mempolicy((int*)&id, nullptr, 0, (void*)addr, MPOL_F_NODE | MPOL_F_ADDR) == -1) {
-    XErrno err;
-    fatal("Failed to get NUMA id for memory at " PTR_FORMAT " (%s)", addr, err.to_string());
-  }
-
-  assert(id < count(), "Invalid NUMA id");
-
-  return id;
+  return 0;
 }
Index: src/hotspot/os/linux/gc/z/zNUMA_linux.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/hotspot/os/linux/gc/z/zNUMA_linux.cpp b/src/hotspot/os/linux/gc/z/zNUMA_linux.cpp
--- a/src/hotspot/os/linux/gc/z/zNUMA_linux.cpp	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/src/hotspot/os/linux/gc/z/zNUMA_linux.cpp	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -31,41 +31,17 @@
 #include "utilities/debug.hpp"
 
 void ZNUMA::pd_initialize() {
-  _enabled = UseNUMA;
+  _enabled = false;
 }
 
 uint32_t ZNUMA::count() {
-  if (!_enabled) {
-    // NUMA support not enabled
-    return 1;
-  }
+  return 1;
+}
 
-  return os::Linux::numa_max_node() + 1;
-}
-
 uint32_t ZNUMA::id() {
-  if (!_enabled) {
-    // NUMA support not enabled
-    return 0;
-  }
+  return 0;
+}
 
-  return os::Linux::get_node_by_cpu(ZCPU::id());
-}
-
 uint32_t ZNUMA::memory_id(uintptr_t addr) {
-  if (!_enabled) {
-    // NUMA support not enabled, assume everything belongs to node zero
-    return 0;
-  }
-
-  uint32_t id = (uint32_t)-1;
-
-  if (ZSyscall::get_mempolicy((int*)&id, nullptr, 0, (void*)addr, MPOL_F_NODE | MPOL_F_ADDR) == -1) {
-    ZErrno err;
-    fatal("Failed to get NUMA id for memory at " PTR_FORMAT " (%s)", addr, err.to_string());
-  }
-
-  assert(id < count(), "Invalid NUMA id");
-
-  return id;
+  return 0;
 }
Index: src/hotspot/os/linux/os_linux.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/hotspot/os/linux/os_linux.cpp b/src/hotspot/os/linux/os_linux.cpp
--- a/src/hotspot/os/linux/os_linux.cpp	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/src/hotspot/os/linux/os_linux.cpp	(revision 66ffa08a1eb301a088b8f50882b0c882ccbf179f)
@@ -1,6 +1,6 @@
 /*
- * Copyright (c) 1999, 2023, Oracle and/or its affiliates. All rights reserved.
- * Copyright (c) 2015, 2022 SAP SE. All rights reserved.
+ * Copyright (c) 1999, 2024, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2024 SAP SE. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -140,10 +140,10 @@
 // for timer info max values which include all bits
 #define ALL_64_BITS CONST64(0xFFFFFFFFFFFFFFFF)
 
-#ifdef MUSL_LIBC
+#if defined(MUSL_LIBC) || defined(__ANDROID__)
 // dlvsym is not a part of POSIX
 // and musl libc doesn't implement it.
-static void *dlvsym(void *handle,
+void *dlvsym(void *handle,
                     const char *symbol,
                     const char *version) {
    // load the latest version of symbol
@@ -218,6 +218,8 @@
 // avoid this
 static bool suppress_primordial_thread_resolution = false;
 
+static bool read_so_path_from_maps(const char* so_name, char* buf, int buflen);
+
 // utility functions
 
 julong os::Linux::available_memory_in_container() {
@@ -375,11 +377,11 @@
 }
 
 #ifndef SYS_gettid
-// i386: 224, ia64: 1105, amd64: 186, sparc: 143
+// i386 & arm: 224, ia64: 1105, amd64: 186, sparc: 143
   #ifdef __ia64__
     #define SYS_gettid 1105
   #else
-    #ifdef __i386__
+    #if defined(__i386__) || defined(__arm__)
       #define SYS_gettid 224
     #else
       #ifdef __amd64__
@@ -387,6 +389,8 @@
       #else
         #ifdef __sparc__
           #define SYS_gettid 143
+        #elif defined(__arm64__) || defined(__aarch64__)
+          #define SYS_gettid 178
         #else
           #error define gettid for the arch
         #endif
@@ -411,7 +415,7 @@
 julong os::Linux::host_swap() {
   struct sysinfo si;
   sysinfo(&si);
-  return (julong)si.totalswap;
+  return (julong)(si.totalswap * si.mem_unit);
 }
 
 // Most versions of linux have a bug where the number of processors are
@@ -574,6 +578,7 @@
 // detecting pthread library
 
 void os::Linux::libpthread_init() {
+#ifndef __ANDROID__
   // Save glibc and pthread version strings.
 #if !defined(_CS_GNU_LIBC_VERSION) || \
     !defined(_CS_GNU_LIBPTHREAD_VERSION)
@@ -598,6 +603,9 @@
   confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);
   os::Linux::set_libpthread_version(str);
 #endif
+#else
+  os::Linux::set_libpthread_version("NPTL");
+#endif
 }
 
 /////////////////////////////////////////////////////////////////////////////
@@ -1439,7 +1447,13 @@
 
 // This must be hard coded because it's the system's temporary
 // directory not the java application's temp directory, ala java.io.tmpdir.
-const char* os::get_temp_directory() { return "/tmp"; }
+const char* os::get_temp_directory() {
+#ifndef __ANDROID__
+  return "/tmp";
+#else
+  return "/data/tmp";
+#endif
+}
 
 // check if addr is inside libjvm.so
 bool os::address_is_in_vm(address addr) {
@@ -1460,6 +1474,9 @@
   return false;
 }
 
+void os::prepare_native_symbols() {
+}
+
 bool os::dll_address_to_function_name(address addr, char *buf,
                                       int buflen, int *offset,
                                       bool demangle) {
@@ -1510,6 +1527,30 @@
   if (offset) *offset = -1;
   return false;
 }
+
+static bool read_so_path_from_maps(const char* so_name, char* buf, int buflen) {
+  FILE *fp = fopen("/proc/self/maps", "r");
+  assert(fp, "Failed to open /proc/self/maps");
+  if (!fp) {
+    return false;
+  }
+
+  char maps_buffer[2048];
+  while (fgets(maps_buffer, 2048, fp) != NULL) {
+    if (strstr(maps_buffer, so_name) == NULL) {
+      continue;
+    }
+
+    char *so_path = strchr(maps_buffer, '/');
+    so_path[strlen(so_path) - 1] = '\0'; // Cut trailing \n
+    jio_snprintf(buf, buflen, "%s", so_path);
+    fclose(fp);
+    return true;
+  }
+
+  fclose(fp);
+  return false;
+}
 
 // Remember the stack's state. The Linux dynamic linker will change
 // the stack to 'executable' at most once, so we must safepoint only once.
@@ -1844,6 +1885,7 @@
 }
 
 const char* os::Linux::dll_path(void* lib) {
+#ifdef RTLD_DI_LINKMAP
   struct link_map *lmap;
   const char* l_path = nullptr;
   assert(lib != nullptr, "dll_path parameter must not be null");
@@ -1853,6 +1895,9 @@
     l_path = lmap->l_name;
   }
   return l_path;
+#else
+  return NULL;
+#endif
 }
 
 static unsigned count_newlines(const char* s) {
@@ -2035,7 +2080,6 @@
   "/etc/mandrake-release",
   "/etc/sun-release",
   "/etc/redhat-release",
-  "/etc/SuSE-release",
   "/etc/lsb-release",
   "/etc/turbolinux-release",
   "/etc/gentoo-release",
@@ -2043,6 +2087,7 @@
   "/etc/angstrom-version",
   "/etc/system-release",
   "/etc/os-release",
+  "/etc/SuSE-release", // Deprecated in favor of os-release since SuSE 12
   nullptr };
 
 void os::Linux::print_distro_info(outputStream* st) {
@@ -2154,6 +2199,8 @@
   // https://www.kernel.org/doc/Documentation/vm/transhuge.txt
   _print_ascii_file_h("/sys/kernel/mm/transparent_hugepage/enabled",
                       "/sys/kernel/mm/transparent_hugepage/enabled", st);
+  _print_ascii_file_h("/sys/kernel/mm/transparent_hugepage/hpage_pmd_size",
+                      "/sys/kernel/mm/transparent_hugepage/hpage_pmd_size", st);
   _print_ascii_file_h("/sys/kernel/mm/transparent_hugepage/defrag (defrag/compaction efforts parameter)",
                       "/sys/kernel/mm/transparent_hugepage/defrag", st);
 }
@@ -2608,6 +2655,20 @@
                                          CAST_FROM_FN_PTR(address, os::jvm_path),
                                          dli_fname, sizeof(dli_fname), nullptr);
   assert(ret, "cannot locate libjvm");
+
+#ifdef __ANDROID__
+  if (dli_fname[0] == '\0') {
+    return;
+  }
+
+  if (strchr(dli_fname, '/') == NULL) {
+    bool ok = read_so_path_from_maps(dli_fname, buf, buflen);
+    assert(ok, "unable to turn relative libjvm.so path into absolute");
+    return;
+  }
+
+  snprintf(buf, buflen, /* "%s/lib/%s/server/%s", java_home_var, cpu_arch, */ "%s", dli_fname);
+#else // !__ANDROID__
   char *rp = nullptr;
   if (ret && dli_fname[0] != '\0') {
     rp = os::Posix::realpath(dli_fname, buf, buflen);
@@ -2673,6 +2734,7 @@
       }
     }
   }
+#endif
 
   strncpy(saved_jvm_path, buf, MAXPATHLEN);
   saved_jvm_path[MAXPATHLEN - 1] = '\0';
@@ -2690,6 +2752,8 @@
 void linux_wrap_code(char* base, size_t size) {
   static volatile jint cnt = 0;
 
+  static_assert(sizeof(off_t) == 8, "Expected Large File Support in this file");
+
   if (!UseOprofile) {
     return;
   }
@@ -2988,7 +3052,8 @@
   }
 
   if (sched_getcpu() == -1) {
-    vm_exit_during_initialization("getcpu(2) system call not supported by kernel");
+    // vm_exit_during_initialization
+    warning("getcpu(2) system call not supported by kernel");
   }
 }
 
@@ -3019,14 +3084,8 @@
   // Especially in dockers, get_mempolicy is not allowed with the default configuration. So it's necessary
   // to check whether the syscalls are available. Currently, only get_mempolicy is checked since checking
   // others like mbind would cause unexpected side effects.
-#ifdef SYS_get_mempolicy
-  int dummy = 0;
-  if (syscall(SYS_get_mempolicy, &dummy, nullptr, 0, (void*)&dummy, 3) == -1) {
-    return false;
-  }
-#endif
-
-  return true;
+
+  return false;
 }
 
 bool os::Linux::libnuma_init() {
@@ -3629,6 +3688,7 @@
 }
 
 bool os::Linux::shm_hugetlbfs_sanity_check(bool warn, size_t page_size) {
+#ifndef __ANDROID__
   // Try to create a large shared memory segment.
   int shmid = shmget(IPC_PRIVATE, page_size, SHM_HUGETLB|IPC_CREAT|SHM_R|SHM_W);
   if (shmid == -1) {
@@ -3650,6 +3710,10 @@
   // Managed to create a segment, now delete it.
   shmctl(shmid, IPC_RMID, nullptr);
   return true;
+#else
+  warning("UseSHM not supported on this platform");
+  return false;
+#endif
 }
 
 // From the coredump_filter documentation:
@@ -3802,15 +3866,17 @@
     return;
   }
 
-  // 2) check if large pages are configured
-  if ( ( UseTransparentHugePages && HugePages::supports_thp() == false) ||
-       (!UseTransparentHugePages && HugePages::supports_static_hugepages() == false) ) {
-    // No large pages configured, return.
+  // 2) check if the OS supports THPs resp. static hugepages.
+  if (UseTransparentHugePages && !HugePages::supports_thp()) {
+    if (!FLAG_IS_DEFAULT(UseTransparentHugePages)) {
+      log_warning(pagesize)("UseTransparentHugePages disabled, transparent huge pages are not supported by the operating system.");
+    }
+    UseLargePages = UseTransparentHugePages = UseHugeTLBFS = UseSHM = false;
+    return;
+  }
+  if (!UseTransparentHugePages && !HugePages::supports_static_hugepages()) {
     warn_no_large_pages_configured();
-    UseLargePages = false;
-    UseTransparentHugePages = false;
-    UseHugeTLBFS = false;
-    UseSHM = false;
+    UseLargePages = UseTransparentHugePages = UseHugeTLBFS = UseSHM = false;
     return;
   }
 
@@ -3883,6 +3949,8 @@
   #define SHM_HUGETLB 04000
 #endif
 
+#ifndef __ANDROID__
+
 #define shm_warning_format(format, ...)              \
   do {                                               \
     if (UseLargePages &&                             \
@@ -3975,8 +4043,11 @@
   }
 }
 
+#endif // !__ANDROID__
+
 char* os::Linux::reserve_memory_special_shm(size_t bytes, size_t alignment,
                                             char* req_addr, bool exec) {
+#ifndef __ANDROID__
   // "exec" is passed in but not used.  Creating the shared image for
   // the code cache doesn't have an SHM_X executable permission to check.
   assert(UseLargePages && UseSHM, "only for SHM large pages");
@@ -4021,6 +4092,10 @@
   shmctl(shmid, IPC_RMID, nullptr);
 
   return addr;
+#else
+  assert(0, "SHM not supported on this platform");
+ return NULL;
+#endif // !__ANDROID__
 }
 
 static void log_on_commit_special_failure(char* req_addr, size_t bytes,
@@ -4147,8 +4222,13 @@
 }
 
 bool os::Linux::release_memory_special_shm(char* base, size_t bytes) {
+#ifndef __ANDROID__
   // detaching the SHM segment will also delete it, see reserve_memory_special_shm()
   return shmdt(base) == 0;
+#else
+  assert(0, "SHM not supported on this platform");
+  return false;
+#endif // SUPPORTS_SHM
 }
 
 bool os::Linux::release_memory_special_huge_tlbfs(char* base, size_t bytes) {
@@ -5006,14 +5086,14 @@
   oflag |= O_CLOEXEC;
 #endif
 
-  int fd = ::open64(path, oflag, mode);
+  int fd = ::open(path, oflag, mode);
   if (fd == -1) return -1;
 
   //If the open succeeded, the file might still be a directory
   {
-    struct stat64 buf64;
-    int ret = ::fstat64(fd, &buf64);
-    int st_mode = buf64.st_mode;
+    struct stat buf;
+    int ret = ::fstat(fd, &buf);
+    int st_mode = buf.st_mode;
 
     if (ret != -1) {
       if ((st_mode & S_IFMT) == S_IFDIR) {
@@ -5050,17 +5130,17 @@
 int os::create_binary_file(const char* path, bool rewrite_existing) {
   int oflags = O_WRONLY | O_CREAT;
   oflags |= rewrite_existing ? O_TRUNC : O_EXCL;
-  return ::open64(path, oflags, S_IREAD | S_IWRITE);
+  return ::open(path, oflags, S_IREAD | S_IWRITE);
 }
 
 // return current position of file pointer
 jlong os::current_file_offset(int fd) {
-  return (jlong)::lseek64(fd, (off64_t)0, SEEK_CUR);
+  return (jlong)::lseek(fd, (off_t)0, SEEK_CUR);
 }
 
 // move file pointer to the specified offset
 jlong os::seek_to_file_offset(int fd, jlong offset) {
-  return (jlong)::lseek64(fd, (off64_t)offset, SEEK_SET);
+  return (jlong)::lseek(fd, (off_t)offset, SEEK_SET);
 }
 
 // Map a block of memory.
@@ -5232,7 +5312,46 @@
 // Linux doesn't yet have a (official) notion of processor sets,
 // so just return the system wide load average.
 int os::loadavg(double loadavg[], int nelem) {
-  return ::getloadavg(loadavg, nelem);
+#ifndef __ANDROID__
+   return ::getloadavg(loadavg, nelem);
+#else
+/*
+ * Copyright (C) 2018 The Android Open Source Project
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+  if (nelem < 0) return -1;
+  if (nelem > 3) nelem = 3;
+  struct sysinfo si;
+  if (sysinfo(&si) == -1) return -1;
+  for (int i = 0; i < nelem; ++i) {
+    loadavg[i] = static_cast<double>(si.loads[i]) / static_cast<double>(1 << SI_LOAD_SHIFT);
+  }
+  return nelem;
+#endif
 }
 
 // Get the default path to the core file
@@ -5561,3 +5680,25 @@
   return false; // musl
 #endif
 }
+
+bool os::pd_dll_unload(void* libhandle, char* ebuf, int ebuflen) {
+
+  if (ebuf && ebuflen > 0) {
+    ebuf[0] = '\0';
+    ebuf[ebuflen - 1] = '\0';
+  }
+
+  bool res = (0 == ::dlclose(libhandle));
+  if (!res) {
+    // error analysis when dlopen fails
+    const char* error_report = ::dlerror();
+    if (error_report == nullptr) {
+      error_report = "dlerror returned no error description";
+    }
+    if (ebuf != nullptr && ebuflen > 0) {
+      snprintf(ebuf, ebuflen - 1, "%s", error_report);
+    }
+  }
+
+  return res;
+} // end: os::pd_dll_unload()
Index: src/hotspot/os/linux/os_perf_linux.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/hotspot/os/linux/os_perf_linux.cpp b/src/hotspot/os/linux/os_perf_linux.cpp
--- a/src/hotspot/os/linux/os_perf_linux.cpp	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/src/hotspot/os/linux/os_perf_linux.cpp	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -45,9 +45,312 @@
 #include <dlfcn.h>
 #include <pthread.h>
 #include <limits.h>
+#ifndef __ANDROID__
 #include <ifaddrs.h>
+#else
+#include <sys/cdefs.h>
+#include <netinet/in.h>
+#include <sys/socket.h>
+#include <linux/if_packet.h>
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+#include <net/if.h>
+#include <stdint.h>
+#endif
 #include <fcntl.h>
 
+#ifdef __ANDROID__
+/*
+ * Copyright (C) 2015 The Android Open Source Project
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+__BEGIN_DECLS
+
+/**
+ * Returned by getifaddrs() and freed by freeifaddrs().
+ */
+struct ifaddrs {
+  /** Pointer to the next element in the linked list. */
+  struct ifaddrs* ifa_next;
+
+  /** Interface name. */
+  char* ifa_name;
+
+  /** Interface flags (like `SIOCGIFFLAGS`). */
+  unsigned int ifa_flags;
+
+  /** Interface address. */
+  struct sockaddr* ifa_addr;
+
+  /** Interface netmask. */
+  struct sockaddr* ifa_netmask;
+
+  union {
+    /** Interface broadcast address (if IFF_BROADCAST is set). */
+    struct sockaddr* ifu_broadaddr;
+
+    /** Interface destination address (if IFF_POINTOPOINT is set). */
+    struct sockaddr* ifu_dstaddr;
+  } ifa_ifu;
+
+  /** Unused. */
+  void* ifa_data;
+};
+
+/** Synonym for `ifa_ifu.ifu_broadaddr` in `struct ifaddrs`. */
+#define ifa_broadaddr ifa_ifu.ifu_broadaddr
+
+/** Synonym for `ifa_ifu.ifu_dstaddr` in `struct ifaddrs`. */
+#define ifa_dstaddr ifa_ifu.ifu_dstaddr
+
+/**
+ * [getifaddrs(3)](http://man7.org/linux/man-pages/man3/getifaddrs.3.html) creates a linked list
+ * of `struct ifaddrs`. The list must be freed by freeifaddrs().
+ *
+ * Returns 0 and stores the list in `*__list_ptr` on success,
+ * and returns -1 and sets `errno` on failure.
+ *
+ * Available since API level 24.
+ */
+int getifaddrs(struct ifaddrs** __list_ptr); // __INTRODUCED_IN(24);
+
+/**
+ * [freeifaddrs(3)](http://man7.org/linux/man-pages/man3/freeifaddrs.3.html) frees a linked list
+ * of `struct ifaddrs` returned by getifaddrs().
+ *
+ * Available since API level 24.
+ */
+void freeifaddrs(struct ifaddrs* __ptr); // __INTRODUCED_IN(24);
+
+__END_DECLS
+
+#define nullptr 0
+
+// The public ifaddrs struct is full of pointers. Rather than track several
+// different allocations, we use a maximally-sized structure with the public
+// part at offset 0, and pointers into its hidden tail.
+struct ifaddrs_storage {
+  // Must come first, so that `ifaddrs_storage` is-a `ifaddrs`.
+  ifaddrs ifa;
+  // The interface index, so we can match RTM_NEWADDR messages with
+  // earlier RTM_NEWLINK messages (to copy the interface flags).
+  int interface_index;
+  // Storage for the pointers in `ifa`.
+  sockaddr_storage addr;
+  sockaddr_storage netmask;
+  sockaddr_storage ifa_ifu;
+  char name[IFNAMSIZ + 1];
+  // Netlink gives us the address family in the header, and the
+  // sockaddr_in or sockaddr_in6 bytes as the payload. We need to
+  // stitch the two bits together into the sockaddr that's part of
+  // our portable interface.
+  void SetAddress(int family, const void* data, size_t byteCount) {
+      addr.ss_family = family;
+      memcpy(SockaddrBytes(family, &addr), data, byteCount);
+      ifa.ifa_addr = reinterpret_cast<sockaddr*>(&addr);
+  }
+  void SetBroadcastAddress(int family, const void* data, size_t byteCount) {
+      ifa_ifu.ss_family = family;
+      memcpy(SockaddrBytes(family, &ifa_ifu), data, byteCount);
+      ifa.ifa_dstaddr = reinterpret_cast<sockaddr*>(&ifa_ifu);
+  }
+  // Netlink gives us the prefix length as a bit count. We need to turn
+  // that into a BSD-compatible netmask represented by a sockaddr*.
+  void SetNetmask(int family, size_t prefix_length) {
+      // ...and work out the netmask from the prefix length.
+      netmask.ss_family = family;
+      uint8_t* dst = SockaddrBytes(family, &netmask);
+      memset(dst, 0xff, prefix_length / 8);
+      if ((prefix_length % 8) != 0) {
+        dst[prefix_length/8] = (0xff << (8 - (prefix_length % 8)));
+      }
+      ifa.ifa_netmask = reinterpret_cast<sockaddr*>(&netmask);
+  }
+  void SetPacketAttributes(int ifindex, unsigned short hatype, unsigned char halen) {
+    sockaddr_ll* sll = reinterpret_cast<sockaddr_ll*>(&addr);
+    sll->sll_ifindex = ifindex;
+    sll->sll_hatype = hatype;
+    sll->sll_halen = halen;
+  }
+ private:
+  // Returns a pointer to the first byte in the address data (which is
+  // stored in network byte order).
+  uint8_t* SockaddrBytes(int family, sockaddr_storage* ss) {
+    if (family == AF_INET) {
+      sockaddr_in* ss4 = reinterpret_cast<sockaddr_in*>(ss);
+      return reinterpret_cast<uint8_t*>(&ss4->sin_addr);
+    } else if (family == AF_INET6) {
+      sockaddr_in6* ss6 = reinterpret_cast<sockaddr_in6*>(ss);
+      return reinterpret_cast<uint8_t*>(&ss6->sin6_addr);
+    } else if (family == AF_PACKET) {
+      sockaddr_ll* sll = reinterpret_cast<sockaddr_ll*>(ss);
+      return reinterpret_cast<uint8_t*>(&sll->sll_addr);
+    }
+    return nullptr;
+  }
+};
+ifaddrs_storage* new_ifaddrs_storage(ifaddrs** list) {
+  ifaddrs_storage *storage;
+  memset(storage, 0, sizeof(*storage));
+  // push_front onto `list`.
+  storage->ifa.ifa_next = *list;
+  *list = reinterpret_cast<ifaddrs*>(storage);
+  return storage;
+}
+#if !defined(__clang__)
+// GCC gets confused by NLMSG_DATA and doesn't realize that the old-style
+// cast is from a system header and should be ignored.
+#pragma GCC diagnostic ignored "-Wold-style-cast"
+#endif
+static void __handle_netlink_response(ifaddrs** out, nlmsghdr* hdr) {
+  if (hdr->nlmsg_type == RTM_NEWLINK) {
+    ifinfomsg* ifi = reinterpret_cast<ifinfomsg*>(NLMSG_DATA(hdr));
+    // Create a new ifaddr entry, and set the interface index and flags.
+    ifaddrs_storage* new_addr = new_ifaddrs_storage(out);
+    new_addr->interface_index = ifi->ifi_index;
+    new_addr->ifa.ifa_flags = ifi->ifi_flags;
+    // Go through the various bits of information and find the name.
+    rtattr* rta = IFLA_RTA(ifi);
+    size_t rta_len = IFLA_PAYLOAD(hdr);
+    while (RTA_OK(rta, rta_len)) {
+      if (rta->rta_type == IFLA_ADDRESS) {
+          if (RTA_PAYLOAD(rta) < sizeof(new_addr->addr)) {
+            new_addr->SetAddress(AF_PACKET, RTA_DATA(rta), RTA_PAYLOAD(rta));
+            new_addr->SetPacketAttributes(ifi->ifi_index, ifi->ifi_type, RTA_PAYLOAD(rta));
+          }
+      } else if (rta->rta_type == IFLA_BROADCAST) {
+          if (RTA_PAYLOAD(rta) < sizeof(new_addr->ifa_ifu)) {
+            new_addr->SetBroadcastAddress(AF_PACKET, RTA_DATA(rta), RTA_PAYLOAD(rta));
+            new_addr->SetPacketAttributes(ifi->ifi_index, ifi->ifi_type, RTA_PAYLOAD(rta));
+          }
+      } else if (rta->rta_type == IFLA_IFNAME) {
+          if (RTA_PAYLOAD(rta) < sizeof(new_addr->name)) {
+            memcpy(new_addr->name, RTA_DATA(rta), RTA_PAYLOAD(rta));
+            new_addr->ifa.ifa_name = new_addr->name;
+          }
+      }
+      rta = RTA_NEXT(rta, rta_len);
+    }
+  } else if (hdr->nlmsg_type == RTM_NEWADDR) {
+    ifaddrmsg* msg = reinterpret_cast<ifaddrmsg*>(NLMSG_DATA(hdr));
+    // We should already know about this from an RTM_NEWLINK message.
+    const ifaddrs_storage* addr = reinterpret_cast<const ifaddrs_storage*>(*out);
+    while (addr != nullptr && addr->interface_index != static_cast<int>(msg->ifa_index)) {
+      addr = reinterpret_cast<const ifaddrs_storage*>(addr->ifa.ifa_next);
+    }
+    // If this is an unknown interface, ignore whatever we're being told about it.
+    if (addr == nullptr) return;
+    // Create a new ifaddr entry and copy what we already know.
+    ifaddrs_storage* new_addr = new_ifaddrs_storage(out);
+    // We can just copy the name rather than look for IFA_LABEL.
+    strcpy(new_addr->name, addr->name);
+    new_addr->ifa.ifa_name = new_addr->name;
+    new_addr->ifa.ifa_flags = addr->ifa.ifa_flags;
+    new_addr->interface_index = addr->interface_index;
+    // Go through the various bits of information and find the address
+    // and any broadcast/destination address.
+    rtattr* rta = IFA_RTA(msg);
+    size_t rta_len = IFA_PAYLOAD(hdr);
+    while (RTA_OK(rta, rta_len)) {
+      if (rta->rta_type == IFA_ADDRESS) {
+        if (msg->ifa_family == AF_INET || msg->ifa_family == AF_INET6) {
+          new_addr->SetAddress(msg->ifa_family, RTA_DATA(rta), RTA_PAYLOAD(rta));
+          new_addr->SetNetmask(msg->ifa_family, msg->ifa_prefixlen);
+        }
+      } else if (rta->rta_type == IFA_BROADCAST) {
+        if (msg->ifa_family == AF_INET || msg->ifa_family == AF_INET6) {
+          new_addr->SetBroadcastAddress(msg->ifa_family, RTA_DATA(rta), RTA_PAYLOAD(rta));
+        }
+      }
+      rta = RTA_NEXT(rta, rta_len);
+    }
+  }
+}
+static bool __send_netlink_request(int fd, int type) {
+  struct NetlinkMessage {
+    nlmsghdr hdr;
+    rtgenmsg msg;
+  } request;
+  memset(&request, 0, sizeof(request));
+  request.hdr.nlmsg_flags = NLM_F_DUMP | NLM_F_REQUEST;
+  request.hdr.nlmsg_type = type;
+  request.hdr.nlmsg_len = sizeof(request);
+  request.msg.rtgen_family = AF_UNSPEC; // All families.
+  return (TEMP_FAILURE_RETRY(send(fd, &request, sizeof(request), 0)) == sizeof(request));
+}
+static bool __read_netlink_responses(int fd, ifaddrs** out, char* buf, size_t buf_len) {
+  ssize_t bytes_read;
+  // Read through all the responses, handing interesting ones to __handle_netlink_response.
+  while ((bytes_read = TEMP_FAILURE_RETRY(recv(fd, buf, buf_len, 0))) > 0) {
+    nlmsghdr* hdr = reinterpret_cast<nlmsghdr*>(buf);
+    for (; NLMSG_OK(hdr, static_cast<size_t>(bytes_read)); hdr = NLMSG_NEXT(hdr, bytes_read)) {
+      if (hdr->nlmsg_type == NLMSG_DONE) return true;
+      if (hdr->nlmsg_type == NLMSG_ERROR) return false;
+      __handle_netlink_response(out, hdr);
+    }
+  }
+  // We only get here if recv fails before we see a NLMSG_DONE.
+  return false;
+}
+int getifaddrs(ifaddrs** out) {
+  // Make cleanup easy.
+  *out = nullptr;
+  // The kernel keeps packets under 8KiB (NLMSG_GOODSIZE),
+  // but that's a bit too large to go on the stack.
+  size_t buf_len = 8192;
+  char* buf = NEW_C_HEAP_ARRAY(char, buf_len, mtInternal);
+  if (buf == nullptr) return -1;
+  // Open the netlink socket and ask for all the links and addresses.
+  int fd = socket(PF_NETLINK, SOCK_RAW | SOCK_CLOEXEC, NETLINK_ROUTE);
+  bool okay = fd != -1 &&
+      __send_netlink_request(fd, RTM_GETLINK) && __read_netlink_responses(fd, out, buf, buf_len) &&
+      __send_netlink_request(fd, RTM_GETADDR) && __read_netlink_responses(fd, out, buf, buf_len);
+  if (!okay) {
+    freeifaddrs(*out);
+    // Ensure that callers crash if they forget to check for success.
+    *out = nullptr;
+  }
+  {
+    int saved_errno = errno;
+    close(fd);
+    FREE_C_HEAP_ARRAY(char, buf);
+    errno = saved_errno;
+  }
+  return okay ? 0 : -1;
+}
+void freeifaddrs(ifaddrs* list) {
+  while (list != nullptr) {
+    ifaddrs* current = list;
+    list = list->ifa_next;
+    free(current);
+  }
+}
+#endif
+
 /**
    /proc/[number]/stat
               Status information about the process.  This is used by ps(1).  It is defined in /usr/src/linux/fs/proc/array.c.
Index: src/hotspot/os/posix/os_posix.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/hotspot/os/posix/os_posix.cpp b/src/hotspot/os/posix/os_posix.cpp
--- a/src/hotspot/os/posix/os_posix.cpp	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/src/hotspot/os/posix/os_posix.cpp	(revision 66ffa08a1eb301a088b8f50882b0c882ccbf179f)
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1999, 2023, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1999, 2024, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -50,6 +50,7 @@
 #include "utilities/vmError.hpp"
 #ifdef AIX
 #include "loadlib_aix.hpp"
+#include "os_aix.hpp"
 #endif
 #ifdef LINUX
 #include "os_linux.hpp"
@@ -74,7 +75,9 @@
 #include <sys/wait.h>
 #include <time.h>
 #include <unistd.h>
+#ifndef __ANDROID__
 #include <utmpx.h>
+#endif
 
 #ifdef __APPLE__
   #include <crt_externs.h>
@@ -293,6 +296,7 @@
 }
 
 static int util_posix_fallocate(int fd, off_t offset, off_t len) {
+  static_assert(sizeof(off_t) == 8, "Expected Large File Support in this file");
 #ifdef __APPLE__
   fstore_t store = { F_ALLOCATECONTIG, F_PEOFPOSMODE, 0, len };
   // First we try to get a continuous chunk of disk space
@@ -453,6 +457,7 @@
 // unfortunately it does not work on macOS and Linux because the utx chain has no entry
 // for reboot at least on my test machines
 void os::Posix::print_uptime_info(outputStream* st) {
+#ifndef __ANDROID__
   int bootsec = -1;
   int currsec = time(nullptr);
   struct utmpx* ent;
@@ -467,6 +472,7 @@
   if (bootsec != -1) {
     os::print_dhm(st, "OS uptime:", (long) (currsec-bootsec));
   }
+#endif
 }
 
 static void print_rlimit(outputStream* st, const char* msg,
@@ -733,34 +739,29 @@
   if (l_path == nullptr) {
     l_path = "<not available>";
   }
-  int res = ::dlclose(lib);
 
-  if (res == 0) {
+  char ebuf[1024];
+  bool res = os::pd_dll_unload(lib, ebuf, sizeof(ebuf));
+
+  if (res) {
     Events::log_dll_message(nullptr, "Unloaded shared library \"%s\" [" INTPTR_FORMAT "]",
                             l_path, p2i(lib));
     log_info(os)("Unloaded shared library \"%s\" [" INTPTR_FORMAT "]", l_path, p2i(lib));
   } else {
-    const char* error_report = ::dlerror();
-    if (error_report == nullptr) {
-      error_report = "dlerror returned no error description";
-    }
-
     Events::log_dll_message(nullptr, "Attempt to unload shared library \"%s\" [" INTPTR_FORMAT "] failed, %s",
-                            l_path, p2i(lib), error_report);
+                            l_path, p2i(lib), ebuf);
     log_info(os)("Attempt to unload shared library \"%s\" [" INTPTR_FORMAT "] failed, %s",
-                  l_path, p2i(lib), error_report);
+                  l_path, p2i(lib), ebuf);
   }
-  // Update the dll cache
-  AIX_ONLY(LoadedLibraries::reload());
   LINUX_ONLY(os::free(l_pathdup));
 }
 
 jlong os::lseek(int fd, jlong offset, int whence) {
-  return (jlong) BSD_ONLY(::lseek) NOT_BSD(::lseek64)(fd, offset, whence);
+  return (jlong) AIX_ONLY(::lseek64) NOT_AIX(::lseek)(fd, offset, whence);
 }
 
 int os::ftruncate(int fd, jlong length) {
-   return BSD_ONLY(::ftruncate) NOT_BSD(::ftruncate64)(fd, length);
+   return AIX_ONLY(::ftruncate64) NOT_AIX(::ftruncate)(fd, length);
 }
 
 const char* os::get_current_directory(char *buf, size_t buflen) {
@@ -1923,11 +1924,31 @@
   const char* argv[4] = {"sh", "-c", cmd, nullptr};
   pid_t pid = -1;
   char** env = os::get_environ();
+#ifndef __ANDROID__
   // Note: cast is needed because posix_spawn() requires - for compatibility with ancient
   // C-code - a non-const argv/envp pointer array. But it is fine to hand in literal
   // strings and just cast the constness away. See also ProcessImpl_md.c.
   int rc = ::posix_spawn(&pid, "/bin/sh", nullptr, nullptr, (char**) argv, env);
   if (rc == 0) {
+#else
+  pid = ::fork();
+
+  if (pid < 0) {
+    // fork failed
+    return -1;
+
+  } else if (pid == 0) {
+    // child process
+
+    ::execve("/bin/sh", (char* const*)argv, env);
+
+    // execve failed
+    ::_exit(-1);
+
+  } else  {
+    // copied from J2SE ..._waitForProcessExit() in UNIXProcess_md.c; we don't
+    // care about the actual exit code, for now.
+#endif
     int status;
     // Wait for the child process to exit.  This returns immediately if
     // the child has already exited. */
@@ -1952,9 +1973,11 @@
       // Unknown exit code; pass it through
       return status;
     }
+#ifndef __ANDROID__
   } else {
     // Don't log, we are inside error handling
     return -1;
+#endif
   }
 }
 
Index: src/hotspot/os_cpu/linux_aarch64/javaThread_linux_aarch64.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/hotspot/os_cpu/linux_aarch64/javaThread_linux_aarch64.hpp b/src/hotspot/os_cpu/linux_aarch64/javaThread_linux_aarch64.hpp
--- a/src/hotspot/os_cpu/linux_aarch64/javaThread_linux_aarch64.hpp	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/src/hotspot/os_cpu/linux_aarch64/javaThread_linux_aarch64.hpp	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -47,6 +47,8 @@
   bool pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava);
 public:
 
-  static Thread *aarch64_get_thread_helper();
+  static Thread *aarch64_get_thread_helper() {
+    return Thread::current();
+  }
 
 #endif // OS_CPU_LINUX_AARCH64_JAVATHREAD_LINUX_AARCH64_HPP
Index: src/hotspot/os_cpu/linux_aarch64/threadLS_linux_aarch64.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/hotspot/os_cpu/linux_aarch64/threadLS_linux_aarch64.S b/src/hotspot/os_cpu/linux_aarch64/threadLS_linux_aarch64.S
--- a/src/hotspot/os_cpu/linux_aarch64/threadLS_linux_aarch64.S	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/src/hotspot/os_cpu/linux_aarch64/threadLS_linux_aarch64.S	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -19,6 +19,7 @@
 // or visit www.oracle.com if you need additional information or have any
 // questions.
 
+#ifndef __ANDROID__
         // JavaThread::aarch64_get_thread_helper()
         //
         // Return the current thread pointer in x0.
@@ -44,3 +45,4 @@
 	ret
 
 	.size _ZN10JavaThread25aarch64_get_thread_helperEv, .-_ZN10JavaThread25aarch64_get_thread_helperEv
+#endif
Index: src/hotspot/os_cpu/linux_arm/linux_arm_32.S
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/hotspot/os_cpu/linux_arm/linux_arm_32.S b/src/hotspot/os_cpu/linux_arm/linux_arm_32.S
--- a/src/hotspot/os_cpu/linux_arm/linux_arm_32.S	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/src/hotspot/os_cpu/linux_arm/linux_arm_32.S	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -88,7 +88,7 @@
         stmia to!, {r3 - r9, ip}
         bgt     dw_f2b_loop_32
 dw_f2b_loop_32_finish:
-        addlts  r2, #32
+        addslt  r2, #32
         beq     disjoint_words_finish
         cmp     r2, #16
 	blt	disjoint_words_small
@@ -136,7 +136,7 @@
         stmia to!, {r3 - r9, ip}
         bgt     cw_f2b_loop_32
 cw_f2b_loop_32_finish:
-        addlts  r2, #32
+        addslt  r2, #32
         beq     conjoint_words_finish
         cmp     r2, #16
 	blt	conjoint_words_small
@@ -169,7 +169,7 @@
         stmdb to!, {r3-r9,ip}
         bgt     cw_b2f_loop_32
 cw_b2f_loop_32_finish:
-        addlts  r2, #32
+        addslt  r2, #32
         beq     conjoint_words_finish
         cmp     r2, #16
 	blt	cw_b2f_copy_small
@@ -221,7 +221,7 @@
         stmia to!, {r3 - r9, ip}
         bgt     cs_f2b_loop_32
 cs_f2b_loop_32_finish:
-        addlts  r2, #32
+        addslt  r2, #32
         beq     conjoint_shorts_finish
         movs    r6, r2, lsr #3
         .align 3
@@ -237,11 +237,11 @@
         beq     conjoint_shorts_finish
         cmp     r2, #4
         ldrh    r3, [from], #2
-        ldrgeh  r4, [from], #2
-        ldrgth  r5, [from], #2
+        ldrhge  r4, [from], #2
+        ldrhgt  r5, [from], #2
         strh    r3, [to], #2
-        strgeh  r4, [to], #2
-        strgth  r5, [to], #2
+        strhge  r4, [to], #2
+        strhgt  r5, [to], #2
         b       conjoint_shorts_finish
 
 	# Destination not aligned
@@ -299,11 +299,11 @@
         beq     conjoint_shorts_finish
         cmp     r2, #4
         ldrh    r3, [from], #2
-        ldrgeh  r4, [from], #2
-        ldrgth  r5, [from], #2
+        ldrhge  r4, [from], #2
+        ldrhgt  r5, [from], #2
         strh    r3, [to], #2
-        strgeh  r4, [to], #2
-        strgth  r5, [to], #2
+        strhge  r4, [to], #2
+        strhgt  r5, [to], #2
         b       conjoint_shorts_finish
 
 	# Src and dest overlap, copy in a descending order
@@ -326,7 +326,7 @@
         stmdb to!, {r3-r9,ip}
         bgt     cs_b2f_loop_32
 cs_b2f_loop_32_finish:
-        addlts  r2, #32
+        addslt  r2, #32
         beq     conjoint_shorts_finish
         cmp     r2, #24
         blt     cs_b2f_16
@@ -352,11 +352,11 @@
 cs_b2f_all_copy:
         cmp     r2, #4
         ldrh    r3, [from, #-2]!
-        ldrgeh  r4, [from, #-2]!
-        ldrgth  r5, [from, #-2]!
+        ldrhge  r4, [from, #-2]!
+        ldrhgt  r5, [from, #-2]!
         strh    r3, [to, #-2]!
-        strgeh  r4, [to, #-2]!
-        strgth  r5, [to, #-2]!
+        strhge  r4, [to, #-2]!
+        strhgt  r5, [to, #-2]!
         b       conjoint_shorts_finish
 
 	# Destination not aligned
@@ -391,7 +391,7 @@
         bgt     cs_b2f_16_loop_u
         beq     conjoint_shorts_finish
 cs_b2f_16_loop_u_finished:
-        addlts  r2, #16
+        addslt  r2, #16
         ldr     r3, [from]
 	cmp     r2, #10
         blt     cs_b2f_2_u_loop
@@ -454,7 +454,7 @@
         stmia to!, {r3 - r9, ip}
         bgt     cl_f2b_loop_32
 cl_f2b_loop_32_finish:
-        addlts  r2, #32
+        addslt  r2, #32
         beq     conjoint_longs_finish
 conjoint_longs_small:
         cmp     r2, #16
@@ -487,7 +487,7 @@
         stmdb 	to!, {r3 - r9, ip}
         bgt     cl_b2f_loop_32
 cl_b2f_loop_32_finish:
-        addlts  r2, #32
+        addslt  r2, #32
         beq     conjoint_longs_finish
         cmp     r2, #16
 	blt	cl_b2f_copy_8
Index: src/hotspot/os_cpu/linux_arm/os_linux_arm.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/hotspot/os_cpu/linux_arm/os_linux_arm.cpp b/src/hotspot/os_cpu/linux_arm/os_linux_arm.cpp
--- a/src/hotspot/os_cpu/linux_arm/os_linux_arm.cpp	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/src/hotspot/os_cpu/linux_arm/os_linux_arm.cpp	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -72,7 +72,11 @@
 # include <pwd.h>
 # include <poll.h>
 # include <ucontext.h>
+#ifndef __ANDROID__
 # include <fpu_control.h>
+#else
+# include "fpu_control.h" //include the local header
+#endif
 # include <asm/ptrace.h>
 
 #define SPELL_REG_SP  "sp"
@@ -90,8 +94,14 @@
 #endif
 
 address os::current_stack_pointer() {
+#if defined(__clang__) || defined(__llvm__)
+  void *sp;
+  __asm__("mov %0, " SPELL_REG_SP : "=r"(sp));
+  return (address) sp;
+#else
   register address sp __asm__ (SPELL_REG_SP);
   return sp;
+#endif
 }
 
 char* os::non_memory_address_word() {
@@ -415,8 +425,8 @@
 #if !defined(__SOFTFP__) && defined(__VFP_FP__)
   // Turn on IEEE-754 compliant VFP mode
   __asm__ volatile (
-    "mov %%r0, #0;"
-    "fmxr fpscr, %%r0"
+    "mov r0, #0;"
+    "fmxr fpscr, r0"
     : /* no output */ : /* no input */ : "r0"
   );
 #endif
Index: src/hotspot/os_cpu/linux_x86/os_linux_x86.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/hotspot/os_cpu/linux_x86/os_linux_x86.cpp b/src/hotspot/os_cpu/linux_x86/os_linux_x86.cpp
--- a/src/hotspot/os_cpu/linux_x86/os_linux_x86.cpp	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/src/hotspot/os_cpu/linux_x86/os_linux_x86.cpp	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -74,8 +74,10 @@
 # include <pwd.h>
 # include <poll.h>
 # include <ucontext.h>
-#ifndef AMD64
+#if !defined(AMD64) && !defined(__ANDROID__)
 # include <fpu_control.h>
+#elif defined(__ANDROID__)
+# include "fpu_control.h"
 #endif
 
 #ifdef AMD64
Index: src/hotspot/share/utilities/elfFile.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/hotspot/share/utilities/elfFile.hpp b/src/hotspot/share/utilities/elfFile.hpp
--- a/src/hotspot/share/utilities/elfFile.hpp	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/src/hotspot/share/utilities/elfFile.hpp	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -47,8 +47,10 @@
 typedef Elf64_Sym       Elf_Sym;
 
 #if !defined(_ALLBSD_SOURCE) || defined(__APPLE__)
+#ifndef ELF_ST_TYPE
 #define ELF_ST_TYPE ELF64_ST_TYPE
 #endif
+#endif
 
 #else
 
@@ -62,7 +64,7 @@
 typedef Elf32_Phdr      Elf_Phdr;
 typedef Elf32_Sym       Elf_Sym;
 
-#if !defined(_ALLBSD_SOURCE) || defined(__APPLE__)
+#if (!defined(_ALLBSD_SOURCE) || defined(__APPLE__)) && !defined(ELF_ST_TYPE)
 #define ELF_ST_TYPE ELF32_ST_TYPE
 #endif
 #endif
Index: src/hotspot/share/utilities/globalDefinitions_gcc.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/hotspot/share/utilities/globalDefinitions_gcc.hpp b/src/hotspot/share/utilities/globalDefinitions_gcc.hpp
--- a/src/hotspot/share/utilities/globalDefinitions_gcc.hpp	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/src/hotspot/share/utilities/globalDefinitions_gcc.hpp	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -48,6 +48,10 @@
 #include <limits.h>
 #include <errno.h>
 
+#if defined(__ANDROID__) && !defined(ANDROID)
+#define ANDROID 1
+#endif
+
 #if defined(LINUX) || defined(_ALLBSD_SOURCE)
 #include <inttypes.h>
 #include <signal.h>
Index: src/java.base/unix/classes/sun/net/dns/ResolverConfigurationImpl.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java.base/unix/classes/sun/net/dns/ResolverConfigurationImpl.java b/src/java.base/unix/classes/sun/net/dns/ResolverConfigurationImpl.java
--- a/src/java.base/unix/classes/sun/net/dns/ResolverConfigurationImpl.java	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/src/java.base/unix/classes/sun/net/dns/ResolverConfigurationImpl.java	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -63,8 +63,9 @@
         ArrayList<String> ll = new ArrayList<>();
 
         try {
+            String resolvPath = System.getProperty("ext.net.resolvPath", "/etc/resolv.conf");
             BufferedReader in =
-                new BufferedReader(new FileReader("/etc/resolv.conf"));
+                new BufferedReader(new FileReader(resolvPath));
             String line;
             while ((line = in.readLine()) != null) {
                 int maxvalues = maxperkeyword;
Index: src/java.base/unix/native/libjava/java_props_md.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java.base/unix/native/libjava/java_props_md.c b/src/java.base/unix/native/libjava/java_props_md.c
--- a/src/java.base/unix/native/libjava/java_props_md.c	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/src/java.base/unix/native/libjava/java_props_md.c	(revision 66ffa08a1eb301a088b8f50882b0c882ccbf179f)
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 1998, 2022, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1998, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -45,6 +45,100 @@
 #ifdef MACOSX
 #include "java_props_macosx.h"
 #endif
+
+#ifdef __ANDROID__
+// From https://android.googlesource.com/platform/bionic/+/master/libc/bionic/langinfo.cpp
+/*
+ * Copyright (C) 2016 The Android Open Source Project
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+char* nl_langinfo(nl_item item) {
+  const char* result = "";
+  switch (item) {
+    case CODESET: result = (MB_CUR_MAX == 1) ? "ASCII" : "UTF-8"; break;
+    case D_T_FMT: result = "%F %T %z"; break;
+    case D_FMT: result = "%F"; break;
+    case T_FMT: result = "%T"; break;
+    case T_FMT_AMPM: result = "%I:%M:%S %p"; break;
+    case AM_STR: result = "AM"; break;
+    case PM_STR: result = "PM"; break;
+    case DAY_1: result = "Sunday"; break;
+    case DAY_2: result = "Monday"; break;
+    case DAY_3: result = "Tuesday"; break;
+    case DAY_4: result = "Wednesday"; break;
+    case DAY_5: result = "Thursday"; break;
+    case DAY_6: result = "Friday"; break;
+    case DAY_7: result = "Saturday"; break;
+    case ABDAY_1: result = "Sun"; break;
+    case ABDAY_2: result = "Mon"; break;
+    case ABDAY_3: result = "Tue"; break;
+    case ABDAY_4: result = "Wed"; break;
+    case ABDAY_5: result = "Thu"; break;
+    case ABDAY_6: result = "Fri"; break;
+    case ABDAY_7: result = "Sat"; break;
+    case MON_1: result = "January"; break;
+    case MON_2: result = "February"; break;
+    case MON_3: result = "March"; break;
+    case MON_4: result = "April"; break;
+    case MON_5: result = "May"; break;
+    case MON_6: result = "June"; break;
+    case MON_7: result = "July"; break;
+    case MON_8: result = "August"; break;
+    case MON_9: result = "September"; break;
+    case MON_10: result = "October"; break;
+    case MON_11: result = "November"; break;
+    case MON_12: result = "December"; break;
+    case ABMON_1: result = "Jan"; break;
+    case ABMON_2: result = "Feb"; break;
+    case ABMON_3: result = "Mar"; break;
+    case ABMON_4: result = "Apr"; break;
+    case ABMON_5: result = "May"; break;
+    case ABMON_6: result = "Jun"; break;
+    case ABMON_7: result = "Jul"; break;
+    case ABMON_8: result = "Aug"; break;
+    case ABMON_9: result = "Sep"; break;
+    case ABMON_10: result = "Oct"; break;
+    case ABMON_11: result = "Nov"; break;
+    case ABMON_12: result = "Dec"; break;
+    case ERA: result = ""; break;
+    case ERA_D_FMT: result = ""; break;
+    case ERA_D_T_FMT: result = ""; break;
+    case ERA_T_FMT: result = ""; break;
+    case ALT_DIGITS: result = ""; break;
+    case RADIXCHAR: result = "."; break;
+    case THOUSEP: result = ""; break;
+    case YESEXPR: result = "^[yY]"; break;
+    case NOEXPR: result = "^[nN]"; break;
+    case CRNCYSTR: result = ""; break;
+    default: break;
+  }
+  return (char*) result;
+}
+#endif
 
 #if defined(_ALLBSD_SOURCE)
 #if !defined(P_tmpdir)
@@ -238,6 +332,11 @@
         *std_language = "en";
         if (language != NULL && mapLookup(language_names, language, std_language) == 0) {
             *std_language = malloc(strlen(language)+1);
+            if (*std_language == NULL) {
+                free(encoding_variant);
+                JNU_ThrowOutOfMemoryError(env, NULL);
+                return 0;
+            }
             strcpy(*std_language, language);
         }
     }
@@ -246,6 +345,11 @@
     if (std_country != NULL && country != NULL) {
         if (mapLookup(country_names, country, std_country) == 0) {
             *std_country = malloc(strlen(country)+1);
+            if (*std_country == NULL) {
+                free(encoding_variant);
+                JNU_ThrowOutOfMemoryError(env, NULL);
+                return 0;
+            }
             strcpy(*std_country, country);
         }
     }
Index: src/java.base/unix/native/libjava/jni_util_md.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java.base/unix/native/libjava/jni_util_md.c b/src/java.base/unix/native/libjava/jni_util_md.c
--- a/src/java.base/unix/native/libjava/jni_util_md.c	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/src/java.base/unix/native/libjava/jni_util_md.c	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -31,7 +31,7 @@
 #include "jni_util.h"
 #include "dlfcn.h"
 
-#if defined(LINUX) && (defined(_GNU_SOURCE) || \
+#if !defined(__ANDROID__) && defined(LINUX) && (defined(_GNU_SOURCE) || \
          (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE < 200112L \
              && defined(_XOPEN_SOURCE) && _XOPEN_SOURCE < 600))
 extern int __xpg_strerror_r(int, char *, size_t);
Index: src/java.base/unix/native/libjli/java_md.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java.base/unix/native/libjli/java_md.c b/src/java.base/unix/native/libjli/java_md.c
--- a/src/java.base/unix/native/libjli/java_md.c	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/src/java.base/unix/native/libjli/java_md.c	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -584,7 +584,58 @@
 SetExecname(char **argv)
 {
     char* exec_path = NULL;
-#if defined(__linux__)
+#if defined(__ANDROID__) //Since both __ANDROID__ and __linux__ are defined, we must let the preprocessor preprocess the __ANDRIOD__ part first
+    char *__java_home = getenv("JAVA_HOME");
+    // From http://hg.openjdk.java.net/mobile/jdk9/jdk/file/17bb8a98d5e3/src/java.base/unix/native/libjli/java_md_solinux.c#l844
+        /* For Android, 'self' would point to /system/bin/app_process
+         * since we are really executing a Dalvik program at this point.
+         * argv[0] points to the Dalvik application name and we set the
+         * path to __java_home.
+         */
+        char buf[PATH_MAX+1];
+        char *p = NULL;
+        if ((p = JLI_StrRChr(argv[0], '/')) != 0) {
+          /* may be running from command line */
+          p++;
+          if ((JLI_StrLen(p) == 4) && JLI_StrCmp(p, "java") == 0) {
+            /* started as 'java'. Must be command line */
+            JLI_TraceLauncher("SetExecName maybe command line = %s\n", argv[0]);
+            if (*argv[0] != '/') {
+              char *curdir = NULL;
+              /* get absolute path */
+              getcwd(buf, PATH_MAX);
+              curdir = JLI_StringDup(buf);
+              JLI_Snprintf(buf, PATH_MAX, "%s/%s", curdir, argv[0]);
+              JLI_MemFree(curdir);
+            } else {
+              JLI_Snprintf(buf, PATH_MAX, "%s", argv[0]);
+            }
+          } else {
+            /* Not command line, see if __java_home set */
+            if (__java_home != NULL) {
+              JLI_TraceLauncher("SetExecName not java = %s\n", __java_home);
+              JLI_Snprintf(buf, PATH_MAX, "%s/bin/java", __java_home);
+            } else {
+              /* Fake it as best we can or should we punt? */
+              JLI_TraceLauncher("SetExecName fake it = %s\n", argv[0]);
+              JLI_Snprintf(buf, PATH_MAX, "/data/data/%s/storage/jvm/bin/java",
+                           argv[0]);
+            }
+          }
+        } else {
+            /* Not started as 'java', see if __java_home set */
+            if (__java_home != NULL) {
+              JLI_TraceLauncher("SetExecName not command line = %s\n", __java_home);
+              JLI_Snprintf(buf, PATH_MAX, "%s/bin/java", __java_home);
+            } else {
+              /* Fake it as best we can or should we punt? */
+              JLI_TraceLauncher("SetExecName fake it 2 = %s\n", argv[0]);
+              JLI_Snprintf(buf, PATH_MAX, "/data/data/%s/storage/jvm/bin/java",
+                           argv[0]);
+            }
+        }
+        exec_path = JLI_StringDup(buf);
+#elif defined(__linux__)
     {
         const char* self = "/proc/self/exe";
         char buf[PATH_MAX+1];
@@ -594,10 +645,6 @@
             exec_path = JLI_StringDup(buf);
         }
     }
-#else /* !__linux__ */
-    {
-        /* Not implemented */
-    }
 #endif
 
     if (exec_path == NULL) {
Index: src/java.base/unix/native/libnet/net_util_md.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java.base/unix/native/libnet/net_util_md.h b/src/java.base/unix/native/libnet/net_util_md.h
--- a/src/java.base/unix/native/libnet/net_util_md.h	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/src/java.base/unix/native/libnet/net_util_md.h	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -26,6 +26,9 @@
 #ifndef NET_UTILS_MD_H
 #define NET_UTILS_MD_H
 
+#ifdef ANDROID
+#include <netinet/in.h>
+#endif
 #include <netdb.h>
 #include <poll.h>
 #include <sys/socket.h>
Index: src/java.base/unix/native/libnio/fs/UnixNativeDispatcher.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java.base/unix/native/libnio/fs/UnixNativeDispatcher.c b/src/java.base/unix/native/libnio/fs/UnixNativeDispatcher.c
--- a/src/java.base/unix/native/libnio/fs/UnixNativeDispatcher.c	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/src/java.base/unix/native/libnio/fs/UnixNativeDispatcher.c	(revision 66ffa08a1eb301a088b8f50882b0c882ccbf179f)
@@ -51,6 +51,7 @@
 
 #ifdef __linux__
 #include <sys/syscall.h>
+#include <sys/sysmacros.h> // makedev macros
 #endif
 
 #if defined(__linux__) || defined(_AIX)
@@ -71,6 +72,98 @@
 #define readdir64 readdir
 #endif
 
+#if defined(__linux__)
+// Account for the case where we compile on a system without statx
+// support. We still want to ensure we can call statx at runtime
+// if the runtime glibc version supports it (>= 2.28). We do this
+// by defining binary compatible statx structs in this file and
+// not relying on included headers.
+
+#ifndef __GLIBC__
+// Alpine doesn't know these types, define them
+typedef unsigned int       __uint32_t;
+typedef unsigned short     __uint16_t;
+typedef unsigned long int  __uint64_t;
+#endif
+
+/*
+ * Timestamp structure for the timestamps in struct statx.
+ */
+struct my_statx_timestamp {
+        int64_t   tv_sec;
+        __uint32_t  tv_nsec;
+        int32_t   __reserved;
+};
+
+/*
+ * struct statx used by statx system call on >= glibc 2.28
+ * systems
+ */
+struct my_statx
+{
+  __uint32_t stx_mask;
+  __uint32_t stx_blksize;
+  __uint64_t stx_attributes;
+  __uint32_t stx_nlink;
+  __uint32_t stx_uid;
+  __uint32_t stx_gid;
+  __uint16_t stx_mode;
+  __uint16_t __statx_pad1[1];
+  __uint64_t stx_ino;
+  __uint64_t stx_size;
+  __uint64_t stx_blocks;
+  __uint64_t stx_attributes_mask;
+  struct my_statx_timestamp stx_atime;
+  struct my_statx_timestamp stx_btime;
+  struct my_statx_timestamp stx_ctime;
+  struct my_statx_timestamp stx_mtime;
+  __uint32_t stx_rdev_major;
+  __uint32_t stx_rdev_minor;
+  __uint32_t stx_dev_major;
+  __uint32_t stx_dev_minor;
+  __uint64_t __statx_pad2[14];
+};
+
+// statx masks, flags, constants
+
+#ifndef AT_SYMLINK_NOFOLLOW
+#define AT_SYMLINK_NOFOLLOW 0x100
+#endif
+
+#ifndef AT_STATX_SYNC_AS_STAT
+#define AT_STATX_SYNC_AS_STAT 0x0000
+#endif
+
+#ifndef AT_EMPTY_PATH
+#define AT_EMPTY_PATH 0x1000
+#endif
+
+#ifndef STATX_BASIC_STATS
+#define STATX_BASIC_STATS 0x000007ffU
+#endif
+
+#ifndef STATX_BTIME
+#define STATX_BTIME 0x00000800U
+#endif
+
+#ifndef STATX_ALL
+#define STATX_ALL (STATX_BTIME | STATX_BASIC_STATS)
+#endif
+
+#ifndef AT_FDCWD
+#define AT_FDCWD -100
+#endif
+
+#ifndef RTLD_DEFAULT
+#define RTLD_DEFAULT RTLD_LOCAL
+#endif
+
+#define NO_FOLLOW_SYMLINK 1
+#define FOLLOW_SYMLINK 0
+
+#endif // __linux__
+
+
 #include "jni.h"
 #include "jni_util.h"
 #include "jlong.h"
@@ -117,9 +210,12 @@
 static jfieldID attrs_st_ctime_sec;
 static jfieldID attrs_st_ctime_nsec;
 
-#ifdef _DARWIN_FEATURE_64_BIT_INODE
+#if defined(_DARWIN_FEATURE_64_BIT_INODE) || defined(__linux__)
 static jfieldID attrs_st_birthtime_sec;
 #endif
+#if defined(__linux__) // Linux has nsec granularity if supported
+static jfieldID attrs_st_birthtime_nsec;
+#endif
 
 static jfieldID attrs_f_frsize;
 static jfieldID attrs_f_blocks;
@@ -140,18 +236,62 @@
 typedef int unlinkat_func(int, const char*, int);
 typedef int renameat_func(int, const char*, int, const char*);
 typedef int futimesat_func(int, const char *, const struct timeval *);
+typedef int utimensat_func(int, const char *, const struct timespec *, int flags);
 typedef int futimens_func(int, const struct timespec *);
 typedef int lutimes_func(const char *, const struct timeval *);
 typedef DIR* fdopendir_func(int);
+#if defined(__linux__)
+typedef int statx_func(int dirfd, const char *restrict pathname, int flags,
+                       unsigned int mask, struct my_statx *restrict statxbuf);
+#endif
 
 static openat64_func* my_openat64_func = NULL;
 static fstatat64_func* my_fstatat64_func = NULL;
 static unlinkat_func* my_unlinkat_func = NULL;
 static renameat_func* my_renameat_func = NULL;
 static futimesat_func* my_futimesat_func = NULL;
+static utimensat_func* my_utimensat_func = NULL;
 static futimens_func* my_futimens_func = NULL;
 static lutimes_func* my_lutimes_func = NULL;
 static fdopendir_func* my_fdopendir_func = NULL;
+#if defined(__linux__)
+static statx_func* my_statx_func = NULL;
+#endif
+
+#ifdef __ANDROID__
+/*
+ * TODO: Android lacks support for the methods listed below.  In it's place are
+ * alternatives that use existing Android functionality, but lack reentrant
+ * support.  Determine if the following are the most suitable alternatives.
+ *
+ */
+int getgrgid_r(gid_t gid, struct group* grp, char* buf, size_t buflen, struct group** result) {
+
+  *result = NULL;
+  errno = 0;
+  grp = getgrgid(gid);
+  if (grp == NULL) {
+        return errno;
+  }
+  // buf not used by caller (see below)
+  *result = grp;
+  return 0;
+}
+
+int getgrnam_r(const char *name, struct group* grp, char* buf, size_t buflen, struct group** result) {
+
+  *result = NULL;
+  errno = 0;
+  grp = getgrnam(name);
+  if (grp == NULL) {
+        return errno;
+  }
+  // buf not used by caller (see below)
+  *result = grp;
+  return 0;
+
+}
+#endif
 
 /**
  * fstatat missing from glibc on Linux.
@@ -177,6 +317,13 @@
 }
 #endif
 
+#if defined(__linux__)
+static int statx_wrapper(int dirfd, const char *restrict pathname, int flags,
+                         unsigned int mask, struct my_statx *restrict statxbuf) {
+    return (*my_statx_func)(dirfd, pathname, flags, mask, statxbuf);
+}
+#endif
+
 /**
  * Call this to throw an internal UnixException when a system/library
  * call fails
@@ -229,10 +376,14 @@
     attrs_st_ctime_nsec = (*env)->GetFieldID(env, clazz, "st_ctime_nsec", "J");
     CHECK_NULL_RETURN(attrs_st_ctime_nsec, 0);
 
-#ifdef _DARWIN_FEATURE_64_BIT_INODE
+#if defined(_DARWIN_FEATURE_64_BIT_INODE) || defined(__linux__)
     attrs_st_birthtime_sec = (*env)->GetFieldID(env, clazz, "st_birthtime_sec", "J");
     CHECK_NULL_RETURN(attrs_st_birthtime_sec, 0);
 #endif
+#if defined (__linux__) // Linux has nsec granularity
+    attrs_st_birthtime_nsec = (*env)->GetFieldID(env, clazz, "st_birthtime_nsec", "J");
+    CHECK_NULL_RETURN(attrs_st_birthtime_nsec, 0);
+#endif
 
     clazz = (*env)->FindClass(env, "sun/nio/fs/UnixFileStoreAttributes");
     CHECK_NULL_RETURN(clazz, 0);
@@ -273,6 +424,9 @@
     my_futimesat_func = (futimesat_func*) dlsym(RTLD_DEFAULT, "futimesat");
     my_lutimes_func = (lutimes_func*) dlsym(RTLD_DEFAULT, "lutimes");
 #endif
+#ifdef __ANDROID__
+    my_utimensat_func = (utimensat_func*) dlsym(RTLD_DEFAULT, "utimensat");
+#endif
     my_futimens_func = (futimens_func*) dlsym(RTLD_DEFAULT, "futimens");
 #if defined(_AIX)
     my_fdopendir_func = (fdopendir_func*) dlsym(RTLD_DEFAULT, "fdopendir64");
@@ -292,7 +446,7 @@
     capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_FUTIMES;
     capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_LUTIMES;
 #else
-    if (my_futimesat_func != NULL)
+    if (my_futimesat_func != NULL || my_utimensat_func != NULL)
         capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_FUTIMES;
     if (my_lutimes_func != NULL)
         capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_LUTIMES;
@@ -304,7 +458,7 @@
 
     if (my_openat64_func != NULL &&  my_fstatat64_func != NULL &&
         my_unlinkat_func != NULL && my_renameat_func != NULL &&
-        my_futimesat_func != NULL && my_fdopendir_func != NULL)
+        (my_futimesat_func != NULL || my_utimensat_func != NULL) && my_fdopendir_func != NULL)
     {
         capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_OPENAT;
     }
@@ -314,6 +468,12 @@
 #ifdef _DARWIN_FEATURE_64_BIT_INODE
     capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_BIRTHTIME;
 #endif
+#if defined(__linux__)
+    my_statx_func = (statx_func*) dlsym(RTLD_DEFAULT, "statx");
+    if (my_statx_func != NULL) {
+        capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_BIRTHTIME;
+    }
+#endif
 
     /* supports extended attributes */
 
@@ -490,10 +650,37 @@
     return (jint)n;
 }
 
+#if defined(__linux__)
+/**
+ * Copy statx members into sun.nio.fs.UnixFileAttributes
+ */
+static void copy_statx_attributes(JNIEnv* env, struct my_statx* buf, jobject attrs) {
+    (*env)->SetIntField(env, attrs, attrs_st_mode, (jint)buf->stx_mode);
+    (*env)->SetLongField(env, attrs, attrs_st_ino, (jlong)buf->stx_ino);
+    (*env)->SetIntField(env, attrs, attrs_st_nlink, (jint)buf->stx_nlink);
+    (*env)->SetIntField(env, attrs, attrs_st_uid, (jint)buf->stx_uid);
+    (*env)->SetIntField(env, attrs, attrs_st_gid, (jint)buf->stx_gid);
+    (*env)->SetLongField(env, attrs, attrs_st_size, (jlong)buf->stx_size);
+    (*env)->SetLongField(env, attrs, attrs_st_atime_sec, (jlong)buf->stx_atime.tv_sec);
+    (*env)->SetLongField(env, attrs, attrs_st_mtime_sec, (jlong)buf->stx_mtime.tv_sec);
+    (*env)->SetLongField(env, attrs, attrs_st_ctime_sec, (jlong)buf->stx_ctime.tv_sec);
+    (*env)->SetLongField(env, attrs, attrs_st_birthtime_sec, (jlong)buf->stx_btime.tv_sec);
+    (*env)->SetLongField(env, attrs, attrs_st_birthtime_nsec, (jlong)buf->stx_btime.tv_nsec);
+    (*env)->SetLongField(env, attrs, attrs_st_atime_nsec, (jlong)buf->stx_atime.tv_nsec);
+    (*env)->SetLongField(env, attrs, attrs_st_mtime_nsec, (jlong)buf->stx_mtime.tv_nsec);
+    (*env)->SetLongField(env, attrs, attrs_st_ctime_nsec, (jlong)buf->stx_ctime.tv_nsec);
+    // convert statx major:minor to dev_t using makedev
+    dev_t dev = makedev(buf->stx_dev_major, buf->stx_dev_minor);
+    dev_t rdev = makedev(buf->stx_rdev_major, buf->stx_rdev_minor);
+    (*env)->SetLongField(env, attrs, attrs_st_dev, (jlong)dev);
+    (*env)->SetLongField(env, attrs, attrs_st_rdev, (jlong)rdev);
+}
+#endif
+
 /**
  * Copy stat64 members into sun.nio.fs.UnixFileAttributes
  */
-static void prepAttributes(JNIEnv* env, struct stat64* buf, jobject attrs) {
+static void copy_stat64_attributes(JNIEnv* env, struct stat64* buf, jobject attrs) {
     (*env)->SetIntField(env, attrs, attrs_st_mode, (jint)buf->st_mode);
     (*env)->SetLongField(env, attrs, attrs_st_ino, (jlong)buf->st_ino);
     (*env)->SetLongField(env, attrs, attrs_st_dev, (jlong)buf->st_dev);
@@ -508,6 +695,7 @@
 
 #ifdef _DARWIN_FEATURE_64_BIT_INODE
     (*env)->SetLongField(env, attrs, attrs_st_birthtime_sec, (jlong)buf->st_birthtime);
+    // rely on default value of 0 for st_birthtime_nsec field on Darwin
 #endif
 
 #ifndef MACOSX
@@ -528,10 +716,25 @@
     int err;
     struct stat64 buf;
     const char* path = (const char*)jlong_to_ptr(pathAddress);
+#if defined(__linux__)
+    struct my_statx statx_buf;
+    int flags = AT_STATX_SYNC_AS_STAT;
+    unsigned int mask = STATX_ALL;
 
+    if (my_statx_func != NULL) {
+        // Prefer statx over stat64 on Linux if it's available
+        RESTARTABLE(statx_wrapper(AT_FDCWD, path, flags, mask, &statx_buf), err);
+        if (err == 0) {
+            copy_statx_attributes(env, &statx_buf, attrs);
+            return 0;
+        } else {
+            return errno;
+        }
+    }
+#endif
     RESTARTABLE(stat64(path, &buf), err);
     if (err == 0) {
-        prepAttributes(env, &buf, attrs);
+        copy_stat64_attributes(env, &buf, attrs);
         return 0;
     } else {
         return errno;
@@ -545,12 +748,28 @@
     int err;
     struct stat64 buf;
     const char* path = (const char*)jlong_to_ptr(pathAddress);
+#if defined(__linux__)
+    struct my_statx statx_buf;
+    int flags = AT_STATX_SYNC_AS_STAT | AT_SYMLINK_NOFOLLOW;
+    unsigned int mask = STATX_ALL;
 
+    if (my_statx_func != NULL) {
+        // Prefer statx over stat64 on Linux if it's available
+        RESTARTABLE(statx_wrapper(AT_FDCWD, path, flags, mask, &statx_buf), err);
+        if (err == 0) {
+            copy_statx_attributes(env, &statx_buf, attrs);
+        } else {
+            throwUnixException(env, errno);
+        }
+        // statx was available, so return now
+        return;
+    }
+#endif
     RESTARTABLE(lstat64(path, &buf), err);
     if (err == -1) {
         throwUnixException(env, errno);
     } else {
-        prepAttributes(env, &buf, attrs);
+        copy_stat64_attributes(env, &buf, attrs);
     }
 }
 
@@ -560,12 +779,29 @@
 {
     int err;
     struct stat64 buf;
+#if defined(__linux__)
+    struct my_statx statx_buf;
+    int flags = AT_EMPTY_PATH | AT_STATX_SYNC_AS_STAT;
+    unsigned int mask = STATX_ALL;
 
+    if (my_statx_func != NULL) {
+        // statx supports FD use via dirfd iff pathname is an empty string and the
+        // AT_EMPTY_PATH flag is specified in flags
+        RESTARTABLE(statx_wrapper((int)fd, "", flags, mask, &statx_buf), err);
+        if (err == 0) {
+            copy_statx_attributes(env, &statx_buf, attrs);
+        } else {
+            throwUnixException(env, errno);
+        }
+        // statx was available, so return now
+        return;
+    }
+#endif
     RESTARTABLE(fstat64((int)fd, &buf), err);
     if (err == -1) {
         throwUnixException(env, errno);
     } else {
-        prepAttributes(env, &buf, attrs);
+        copy_stat64_attributes(env, &buf, attrs);
     }
 }
 
@@ -576,6 +812,26 @@
     int err;
     struct stat64 buf;
     const char* path = (const char*)jlong_to_ptr(pathAddress);
+#if defined(__linux__)
+    struct my_statx statx_buf;
+    int flags = AT_STATX_SYNC_AS_STAT;
+    unsigned int mask = STATX_ALL;
+
+    if (my_statx_func != NULL) {
+        // Prefer statx over stat64 on Linux if it's available
+        if (((int)flag & AT_SYMLINK_NOFOLLOW) > 0) { // flag set in java code
+            flags |= AT_SYMLINK_NOFOLLOW;
+        }
+        RESTARTABLE(statx_wrapper((int)dfd, path, flags, mask, &statx_buf), err);
+        if (err == 0) {
+            copy_statx_attributes(env, &statx_buf, attrs);
+        } else {
+            throwUnixException(env, errno);
+        }
+        // statx was available, so return now
+        return;
+    }
+#endif
 
     if (my_fstatat64_func == NULL) {
         JNU_ThrowInternalError(env, "should not reach here");
@@ -585,7 +841,7 @@
     if (err == -1) {
         throwUnixException(env, errno);
     } else {
-        prepAttributes(env, &buf, attrs);
+        copy_stat64_attributes(env, &buf, attrs);
     }
 }
 
@@ -675,22 +931,30 @@
     jlong accessTime, jlong modificationTime)
 {
     struct timeval times[2];
+    struct timespec times2[2];
     int err = 0;
 
-    times[0].tv_sec = accessTime / 1000000;
+    times[0].tv_sec = times2[0].tv_sec = accessTime / 1000000;
     times[0].tv_usec = accessTime % 1000000;
 
-    times[1].tv_sec = modificationTime / 1000000;
+    times[1].tv_sec = times2[1].tv_sec = modificationTime / 1000000;
     times[1].tv_usec = modificationTime % 1000000;
 
+    times2[0].tv_nsec = times[0].tv_usec * 1000;
+    times2[1].tv_nsec = times[1].tv_usec * 1000;
+
 #ifdef _ALLBSD_SOURCE
     RESTARTABLE(futimes(filedes, &times[0]), err);
 #else
-    if (my_futimesat_func == NULL) {
-        JNU_ThrowInternalError(env, "my_futimesat_func is NULL");
+    if (my_futimesat_func == NULL && my_utimensat_func == NULL) {
+        JNU_ThrowInternalError(env, "my_futimesat_func and my_utimensat_func are NULL");
         return;
     }
-    RESTARTABLE((*my_futimesat_func)(filedes, NULL, &times[0]), err);
+    if (my_futimesat_func != NULL) {
+        RESTARTABLE((*my_futimesat_func)(filedes, NULL, &times[0]), err);
+    } else {
+        RESTARTABLE((*my_utimensat_func)(filedes, NULL, &times2[0], 0), err);
+    }
 #endif
     if (err == -1) {
         throwUnixException(env, errno);
Index: src/java.desktop/unix/native/libawt/awt/awt_LoadLibrary.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java.desktop/unix/native/libawt/awt/awt_LoadLibrary.c b/src/java.desktop/unix/native/libawt/awt/awt_LoadLibrary.c
--- a/src/java.desktop/unix/native/libawt/awt/awt_LoadLibrary.c	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/src/java.desktop/unix/native/libawt/awt/awt_LoadLibrary.c	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -30,6 +30,7 @@
 #include <jni.h>
 #include <jni_util.h>
 #include <jvm.h>
+#include <stdbool.h>
 #include "gdefs.h"
 
 #include <sys/param.h>
@@ -98,6 +99,30 @@
   #define HEADLESS_PATH "/libawt_headless.so"
 #endif
 
+static bool read_so_path_from_maps(const char* so_name, char* buf) {
+  FILE *fp = fopen("/proc/self/maps", "r");
+
+  if (!fp) {
+    return false;
+  }
+
+  char maps_buffer[2048];
+  while (fgets(maps_buffer, 2048, fp) != NULL) {
+    if (strstr(maps_buffer, so_name) == NULL) {
+      continue;
+    }
+
+    char *so_path = strchr(maps_buffer, '/');
+    so_path[strlen(so_path) - 1] = '\0'; // Cut trailing \n
+      strcpy(buf,so_path);
+    fclose(fp);
+    return true;
+  }
+
+  fclose(fp);
+  return false;
+}
+
 jint
 AWT_OnLoad(JavaVM *vm, void *reserved)
 {
@@ -119,7 +144,11 @@
 #ifndef STATIC_BUILD
     /* Get address of this library and the directory containing it. */
     dladdr((void *)AWT_OnLoad, &dlinfo);
-    realpath((char *)dlinfo.dli_fname, buf);
+    if (strrchr(dlinfo.dli_fname, '/') != NULL) {
+        realpath((char *)dlinfo.dli_fname, buf);
+    }else{
+        read_so_path_from_maps(dlinfo.dli_fname,buf);
+    }
     len = strlen(buf);
     p = strrchr(buf, '/');
 #endif
Index: src/java.instrument/unix/native/libinstrument/EncodingSupport_md.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java.instrument/unix/native/libinstrument/EncodingSupport_md.c b/src/java.instrument/unix/native/libinstrument/EncodingSupport_md.c
--- a/src/java.instrument/unix/native/libinstrument/EncodingSupport_md.c	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/src/java.instrument/unix/native/libinstrument/EncodingSupport_md.c	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -65,7 +65,11 @@
     (void)setlocale(LC_ALL, "");
 
     /* Get the codeset name */
+#ifndef __ANDROID__
     codeset = (char*)nl_langinfo(CODESET);
+#else
+    codeset = "ASCII"; // (MB_CUR_MAX == 1) ? "ASCII" : "UTF-8";
+#endif
     if ( codeset == NULL || codeset[0] == 0 ) {
         UTF_DEBUG(("NO codeset returned by nl_langinfo(CODESET)\n"));
         return;
Index: src/jdk.jdwp.agent/share/native/libjdwp/utf_util.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/jdk.jdwp.agent/share/native/libjdwp/utf_util.c b/src/jdk.jdwp.agent/share/native/libjdwp/utf_util.c
--- a/src/jdk.jdwp.agent/share/native/libjdwp/utf_util.c	(revision 060c4f7589e7f13febd402f4dac3320f4c032b08)
+++ b/src/jdk.jdwp.agent/share/native/libjdwp/utf_util.c	(revision b739ccbad43fd9456e30fd990bf90d966150ee1f)
@@ -483,7 +483,11 @@
         // locale is not initialized, do it now
         if (setlocale(LC_ALL, "") != NULL) {
             // nl_langinfo returns ANSI_X3.4-1968 by default
+#ifndef __ANDROID__
             codeset = (char*)nl_langinfo(CODESET);
+#else
+            codeset = "ASCII";
+#endif
         }
 
         if (codeset == NULL) {
Index: src/hotspot/os_cpu/linux_arm/fpu_control.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/hotspot/os_cpu/linux_arm/fpu_control.h b/src/hotspot/os_cpu/linux_arm/fpu_control.h
new file mode 100644
--- /dev/null	(revision b002a55313fbd2e3af200f0ea77ccf0fbfd0885a)
+++ b/src/hotspot/os_cpu/linux_arm/fpu_control.h	(revision b002a55313fbd2e3af200f0ea77ccf0fbfd0885a)
@@ -0,0 +1,59 @@
+/* FPU control word definitions.  ARM VFP version.
+   Copyright (C) 2004-2019 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+#ifndef _FPU_CONTROL_H
+#define _FPU_CONTROL_H
+#if !(defined(_LIBC) && !defined(_LIBC_TEST)) && defined(__SOFTFP__)
+#define _FPU_RESERVED 0xffffffff
+#define _FPU_DEFAULT  0x00000000
+typedef unsigned int fpu_control_t;
+#define _FPU_GETCW(cw) (cw) = 0
+#define _FPU_SETCW(cw) (void) (cw)
+extern fpu_control_t __fpu_control;
+#else
+/* masking of interrupts */
+#define _FPU_MASK_IM        0x00000100        /* invalid operation */
+#define _FPU_MASK_ZM        0x00000200        /* divide by zero */
+#define _FPU_MASK_OM        0x00000400        /* overflow */
+#define _FPU_MASK_UM        0x00000800        /* underflow */
+#define _FPU_MASK_PM        0x00001000        /* inexact */
+#define _FPU_MASK_NZCV        0xf0000000        /* NZCV flags */
+#define _FPU_MASK_RM        0x00c00000        /* rounding mode */
+#define _FPU_MASK_EXCEPT 0x00001f1f        /* all exception flags */
+/* Some bits in the FPSCR are not yet defined.  They must be preserved when
+   modifying the contents.  */
+#define _FPU_RESERVED        0x00086060
+#define _FPU_DEFAULT    0x00000000
+/* Default + exceptions enabled.  */
+#define _FPU_IEEE        (_FPU_DEFAULT | 0x00001f00)
+/* Type of the control word.  */
+typedef unsigned int fpu_control_t;
+/* Macros for accessing the hardware control word.  */
+#ifdef __SOFTFP__
+/* This is fmrx %0, fpscr.  */
+# define _FPU_GETCW(cw) \
+  __asm__ __volatile__ ("mrc p10, 7, %0, cr1, cr0, 0" : "=r" (cw))
+/* This is fmxr fpscr, %0.  */
+# define _FPU_SETCW(cw) \
+  __asm__ __volatile__ ("mcr p10, 7, %0, cr1, cr0, 0" : : "r" (cw))
+#else
+# define _FPU_GETCW(cw) \
+  __asm__ __volatile__ ("vmrs %0, fpscr" : "=r" (cw))
+# define _FPU_SETCW(cw) \
+  __asm__ __volatile__ ("vmsr fpscr, %0" : : "r" (cw))
+#endif
+/* Default control word set at startup.  */
+extern fpu_control_t __fpu_control;
+#endif /* __SOFTFP__ */
+#endif /* _FPU_CONTROL_H */
Index: src/hotspot/os_cpu/linux_x86/fpu_control.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/hotspot/os_cpu/linux_x86/fpu_control.h b/src/hotspot/os_cpu/linux_x86/fpu_control.h
new file mode 100644
--- /dev/null	(revision b002a55313fbd2e3af200f0ea77ccf0fbfd0885a)
+++ b/src/hotspot/os_cpu/linux_x86/fpu_control.h	(revision b002a55313fbd2e3af200f0ea77ccf0fbfd0885a)
@@ -0,0 +1,109 @@
+/* FPU control word bits.  x86 version.
+   Copyright (C) 1993-2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Olaf Flebbe.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _FPU_CONTROL_H
+#define _FPU_CONTROL_H	1
+
+/* Note that this file sets on x86-64 only the x87 FPU, it does not
+   touch the SSE unit.  */
+
+/* Here is the dirty part. Set up your 387 through the control word
+ * (cw) register.
+ *
+ *     15-13    12  11-10  9-8     7-6     5    4    3    2    1    0
+ * | reserved | IC | RC  | PC | reserved | PM | UM | OM | ZM | DM | IM
+ *
+ * IM: Invalid operation mask
+ * DM: Denormalized operand mask
+ * ZM: Zero-divide mask
+ * OM: Overflow mask
+ * UM: Underflow mask
+ * PM: Precision (inexact result) mask
+ *
+ * Mask bit is 1 means no interrupt.
+ *
+ * PC: Precision control
+ * 11 - round to extended precision
+ * 10 - round to double precision
+ * 00 - round to single precision
+ *
+ * RC: Rounding control
+ * 00 - rounding to nearest
+ * 01 - rounding down (toward - infinity)
+ * 10 - rounding up (toward + infinity)
+ * 11 - rounding toward zero
+ *
+ * IC: Infinity control
+ * That is for 8087 and 80287 only.
+ *
+ * The hardware default is 0x037f which we use.
+ */
+
+#include <features.h>
+
+/* masking of interrupts */
+#define _FPU_MASK_IM  0x01
+#define _FPU_MASK_DM  0x02
+#define _FPU_MASK_ZM  0x04
+#define _FPU_MASK_OM  0x08
+#define _FPU_MASK_UM  0x10
+#define _FPU_MASK_PM  0x20
+
+/* precision control */
+#define _FPU_EXTENDED 0x300	/* libm requires double extended precision.  */
+#define _FPU_DOUBLE   0x200
+#define _FPU_SINGLE   0x0
+
+/* rounding control */
+#define _FPU_RC_NEAREST 0x0    /* RECOMMENDED */
+#define _FPU_RC_DOWN    0x400
+#define _FPU_RC_UP      0x800
+#define _FPU_RC_ZERO    0xC00
+
+#define _FPU_RESERVED 0xF0C0  /* Reserved bits in cw */
+
+
+/* The fdlibm code requires strict IEEE double precision arithmetic,
+   and no interrupts for exceptions, rounding to nearest.  */
+
+#define _FPU_DEFAULT  0x037f
+
+/* IEEE:  same as above.  */
+#define _FPU_IEEE     0x037f
+
+/* Type of the control word.  */
+typedef unsigned int fpu_control_t __attribute__ ((__mode__ (__HI__)));
+
+/* Macros for accessing the hardware control word.  "*&" is used to
+   work around a bug in older versions of GCC.  __volatile__ is used
+   to support combination of writing the control register and reading
+   it back.  Without __volatile__, the old value may be used for reading
+   back under compiler optimization.
+
+   Note that the use of these macros is not sufficient anymore with
+   recent hardware nor on x86-64.  Some floating point operations are
+   executed in the SSE/SSE2 engines which have their own control and
+   status register.  */
+#define _FPU_GETCW(cw) __asm__ __volatile__ ("fnstcw %0" : "=m" (*&cw))
+#define _FPU_SETCW(cw) __asm__ __volatile__ ("fldcw %0" : : "m" (*&cw))
+
+/* Default control word set at startup.  */
+extern fpu_control_t __fpu_control;
+
+#endif	/* fpu_control.h */
Index: src/java.base/share/classes/sun/launcher/resources/launcher_en.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java.base/share/classes/sun/launcher/resources/launcher_en.properties b/src/java.base/share/classes/sun/launcher/resources/launcher_en.properties
new file mode 100644
--- /dev/null	(revision b002a55313fbd2e3af200f0ea77ccf0fbfd0885a)
+++ b/src/java.base/share/classes/sun/launcher/resources/launcher_en.properties	(revision b002a55313fbd2e3af200f0ea77ccf0fbfd0885a)
@@ -0,0 +1,268 @@
+#
+# Copyright (c) 2007, 2023, Oracle and/or its affiliates. All rights reserved.
+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+#
+# This code is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License version 2 only, as
+# published by the Free Software Foundation.  Oracle designates this
+# particular file as subject to the "Classpath" exception as provided
+# by Oracle in the LICENSE file that accompanied this code.
+#
+# This code is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# version 2 for more details (a copy is included in the LICENSE file that
+# accompanied this code).
+#
+# You should have received a copy of the GNU General Public License version
+# 2 along with this work; if not, write to the Free Software Foundation,
+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+#
+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+# or visit www.oracle.com if you need additional information or have any
+# questions.
+#
+
+# Translators please note do not translate the options themselves
+java.launcher.opt.header  =   Usage: {0} [options] <mainclass> [args...]\n\
+\           (to execute a class)\n\
+\   or  {0} [options] -jar <jarfile> [args...]\n\
+\           (to execute a jar file)\n\
+\   or  {0} [options] -m <module>[/<mainclass>] [args...]\n\
+\       {0} [options] --module <module>[/<mainclass>] [args...]\n\
+\           (to execute the main class in a module)\n\
+\   or  {0} [options] <sourcefile> [args]\n\
+\           (to execute a single source-file program)\n\n\
+\ Arguments following the main class, source file, -jar <jarfile>,\n\
+\ -m or --module <module>/<mainclass> are passed as the arguments to\n\
+\ main class.\n\n\
+\ where options include:\n\n
+
+java.launcher.opt.vmselect   =\    {0}\t  to select the "{1}" VM\n
+java.launcher.opt.hotspot    =\    {0}\t  is a synonym for the "{1}" VM  [deprecated]\n
+
+# Translators please note do not translate the options themselves
+java.launcher.opt.footer = \
+\    -cp <class search path of directories and zip/jar files>\n\
+\    -classpath <class search path of directories and zip/jar files>\n\
+\    --class-path <class search path of directories and zip/jar files>\n\
+\                  A {0} separated list of directories, JAR archives,\n\
+\                  and ZIP archives to search for class files.\n\
+\    -p <module path>\n\
+\    --module-path <module path>...\n\
+\                  A {0} separated list of elements, each element is a file path\n\
+\                  to a module or a directory containing modules. Each module is either\n\
+\                  a modular JAR or an exploded-module directory.\n\
+\    --upgrade-module-path <module path>...\n\
+\                  A {0} separated list of elements, each element is a file path\n\
+\                  to a module or a directory containing modules to replace\n\
+\                  upgradeable modules in the runtime image. Each module is either\n\
+\                  a modular JAR or an exploded-module directory.\n\
+\    --add-modules <module name>[,<module name>...]\n\
+\                  root modules to resolve in addition to the initial module.\n\
+\                  <module name> can also be ALL-DEFAULT, ALL-SYSTEM,\n\
+\                  ALL-MODULE-PATH.\n\
+\    --enable-native-access <module name>[,<module name>...]\n\
+\                  modules that are permitted to perform restricted native operations.\n\
+\                  <module name> can also be ALL-UNNAMED.\n\
+\    --list-modules\n\
+\                  list observable modules and exit\n\
+\    -d <module name>\n\
+\    --describe-module <module name>\n\
+\                  describe a module and exit\n\
+\    --dry-run     create VM and load main class but do not execute main method.\n\
+\                  The --dry-run option may be useful for validating the\n\
+\                  command-line options such as the module system configuration.\n\
+\    --validate-modules\n\
+\                  validate all modules and exit\n\
+\                  The --validate-modules option may be useful for finding\n\
+\                  conflicts and other errors with modules on the module path.\n\
+\    -D<name>=<value>\n\
+\                  set a system property\n\
+\    -verbose:[class|module|gc|jni]\n\
+\                  enable verbose output for the given subsystem\n\
+\    -version      print product version to the error stream and exit\n\
+\    --version     print product version to the output stream and exit\n\
+\    -showversion  print product version to the error stream and continue\n\
+\    --show-version\n\
+\                  print product version to the output stream and continue\n\
+\    --show-module-resolution\n\
+\                  show module resolution output during startup\n\
+\    -? -h -help\n\
+\                  print this help message to the error stream\n\
+\    --help        print this help message to the output stream\n\
+\    -X            print help on extra options to the error stream\n\
+\    --help-extra  print help on extra options to the output stream\n\
+\    -ea[:<packagename>...|:<classname>]\n\
+\    -enableassertions[:<packagename>...|:<classname>]\n\
+\                  enable assertions with specified granularity\n\
+\    -da[:<packagename>...|:<classname>]\n\
+\    -disableassertions[:<packagename>...|:<classname>]\n\
+\                  disable assertions with specified granularity\n\
+\    -esa | -enablesystemassertions\n\
+\                  enable system assertions\n\
+\    -dsa | -disablesystemassertions\n\
+\                  disable system assertions\n\
+\    -agentlib:<libname>[=<options>]\n\
+\                  load native agent library <libname>, e.g. -agentlib:jdwp\n\
+\                  see also -agentlib:jdwp=help\n\
+\    -agentpath:<pathname>[=<options>]\n\
+\                  load native agent library by full pathname\n\
+\    -javaagent:<jarpath>[=<options>]\n\
+\                  load Java programming language agent, see java.lang.instrument\n\
+\    -splash:<imagepath>\n\
+\                  show splash screen with specified image\n\
+\                  HiDPI scaled images are automatically supported and used\n\
+\                  if available. The unscaled image filename, e.g. image.ext,\n\
+\                  should always be passed as the argument to the -splash option.\n\
+\                  The most appropriate scaled image provided will be picked up\n\
+\                  automatically.\n\
+\                  See the SplashScreen API documentation for more information\n\
+\    @argument files\n\
+\                  one or more argument files containing options\n\
+\    --disable-@files\n\
+\                  prevent further argument file expansion\n\
+\    --enable-preview\n\
+\                  allow classes to depend on preview features of this release\n\
+\To specify an argument for a long option, you can use --<name>=<value> or\n\
+\--<name> <value>.\n
+
+# Translators please note do not translate the options themselves
+java.launcher.X.usage=\n\
+\    -Xbatch           disable background compilation\n\
+\    -Xbootclasspath/a:<directories and zip/jar files separated by {0}>\n\
+\                      append to end of bootstrap class path\n\
+\    -Xcheck:jni       perform additional checks for JNI functions\n\
+\    -Xcomp            forces compilation of methods on first invocation\n\
+\    -Xdebug           does nothing. Provided for backward compatibility.\n\
+\    -Xdiag            show additional diagnostic messages\n\
+\    -Xfuture          enable strictest checks, anticipating future default.\n\
+\                      This option is deprecated and may be removed in a\n\
+\                      future release.\n\
+\    -Xint             interpreted mode execution only\n\
+\    -Xinternalversion\n\
+\                      displays more detailed JVM version information than the\n\
+\                      -version option\n\
+\    -Xlog:<opts>      Configure or enable logging with the Java Virtual\n\
+\                      Machine (JVM) unified logging framework. Use -Xlog:help\n\
+\                      for details.\n\
+\    -Xloggc:<file>    log GC status to a file with time stamps.\n\
+\                      This option is deprecated and may be removed in a\n\
+\                      future release. It is replaced by -Xlog:gc:<file>.\n\
+\    -Xmixed           mixed mode execution (default)\n\
+\    -Xmn<size>        sets the initial and maximum size (in bytes) of the heap\n\
+\                      for the young generation (nursery)\n\
+\    -Xms<size>        set initial Java heap size\n\
+\    -Xmx<size>        set maximum Java heap size\n\
+\    -Xnoclassgc       disable class garbage collection\n\
+\    -Xrs              reduce use of OS signals by Java/VM (see documentation)\n\
+\    -Xshare:auto      use shared class data if possible (default)\n\
+\    -Xshare:off       do not attempt to use shared class data\n\
+\    -Xshare:on        require using shared class data, otherwise fail.\n\
+\                      This is a testing option and may lead to intermittent\n\
+\                      failures. It should not be used in production environments.\n\
+\    -XshowSettings    show all settings and continue\n\
+\    -XshowSettings:all\n\
+\                      show all settings and continue\n\
+\    -XshowSettings:locale\n\
+\                      show all locale related settings and continue\n\
+\    -XshowSettings:properties\n\
+\                      show all property settings and continue\n\
+\    -XshowSettings:vm\n\
+\                      show all vm related settings and continue\n\
+\    -XshowSettings:system\n\
+\                      (Linux Only) show host system or container\n\
+\                      configuration and continue\n\
+\    -Xss<size>        set java thread stack size\n\
+\                      The actual size may be rounded up to a multiple of the\n\
+\                      system page size as required by the operating system.\n\
+\    -Xverify          sets the mode of the bytecode verifier\n\
+\                      Note that option -Xverify:none is deprecated and\n\
+\                      may be removed in a future release.\n\
+\    --add-reads <module>=<target-module>(,<target-module>)*\n\
+\                      updates <module> to read <target-module>, regardless\n\
+\                      of module declaration. \n\
+\                      <target-module> can be ALL-UNNAMED to read all unnamed\n\
+\                      modules.\n\
+\    --add-exports <module>/<package>=<target-module>(,<target-module>)*\n\
+\                      updates <module> to export <package> to <target-module>,\n\
+\                      regardless of module declaration.\n\
+\                      <target-module> can be ALL-UNNAMED to export to all\n\
+\                      unnamed modules.\n\
+\    --add-opens <module>/<package>=<target-module>(,<target-module>)*\n\
+\                      updates <module> to open <package> to\n\
+\                      <target-module>, regardless of module declaration.\n\
+\    --limit-modules <module name>[,<module name>...]\n\
+\                      limit the universe of observable modules\n\
+\    --patch-module <module>=<file>({0}<file>)*\n\
+\                      override or augment a module with classes and resources\n\
+\                      in JAR files or directories.\n\
+\    --source <version>\n\
+\                      set the version of the source in source-file mode.\n\
+\    --finalization=<value>\n\
+\                      controls whether the JVM performs finalization of objects,\n\
+\                      where <value> is one of "enabled" or "disabled".\n\
+\                      Finalization is enabled by default.\n\n\
+These extra options are subject to change without notice.\n
+
+# Translators please note do not translate the options themselves
+java.launcher.X.macosx.usage=\
+\n\
+The following options are macOS specific:\n\
+\    -XstartOnFirstThread\n\
+\                      run the main() method on the first (AppKit) thread\n\
+\    -Xdock:name=<application name>\n\
+\                      override default application name displayed in dock\n\
+\    -Xdock:icon=<path to icon file>\n\
+\                      override default icon displayed in dock\n\n
+
+java.launcher.cls.error1=\
+    Error: Could not find or load main class {0}\n\
+    Caused by: {1}: {2}
+java.launcher.cls.error2=\
+    Error: Main method is not {0} in class {1}, please define the main method as:\n\
+\   public static void main(String[] args)
+java.launcher.cls.error3=\
+    Error: Main method must return a value of type void in class {0}, please \n\
+    define the main method as:\n\
+\   public static void main(String[] args)
+java.launcher.cls.error4=\
+    Error: Main method not found in class {0}, please define the main method as:\n\
+\   public static void main(String[] args)\n\
+    or a JavaFX application class must extend {1}
+java.launcher.cls.error5=\
+    Error: JavaFX runtime components are missing, and are required to run this application
+java.launcher.cls.error6=\
+    Error: LinkageError occurred while loading main class {0}\n\
+    \t{1}
+java.launcher.cls.error7=\
+     Error: Unable to initialize main class {0}\n\
+     Caused by: {1}: {2}
+java.launcher.cls.error8=\
+    Error: no non-private zero argument constructor found in class {0}\n\
+    remove private from existing constructor or define as:\n\
+\   public {0}()
+java.launcher.cls.error9=\
+    Error: non-static inner class {0} constructor can not be invoked \n\
+    make inner class static or move inner class out to separate source file
+java.launcher.jar.error1=\
+    Error: An unexpected error occurred while trying to open file {0}
+java.launcher.jar.error2=manifest not found in {0}
+java.launcher.jar.error3=no main manifest attribute, in {0}
+java.launcher.jar.error4=error loading java agent in {0}
+java.launcher.init.error=initialization error
+java.launcher.javafx.error1=\
+    Error: The JavaFX launchApplication method has the wrong signature, it\n\
+    must be declared static and return a value of type void
+java.launcher.module.error1=\
+    module {0} does not have a ModuleMainClass attribute, use -m <module>/<main-class>
+java.launcher.module.error2=\
+    Error: Could not find or load main class {0} in module {1}
+java.launcher.module.error3=\
+    Error: Unable to load main class {0} in module {1}\n\
+    \t{2}
+java.launcher.module.error4=\
+    {0} not found
+java.launcher.module.error5=\
+    Error: Unable to initialize main class {0} in module {1}\n\
+    Caused by: {2}: {3}
Index: src/java.base/share/native/libtinyiconv/iconv.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java.base/share/native/libtinyiconv/iconv.cpp b/src/java.base/share/native/libtinyiconv/iconv.cpp
new file mode 100644
--- /dev/null	(revision b002a55313fbd2e3af200f0ea77ccf0fbfd0885a)
+++ b/src/java.base/share/native/libtinyiconv/iconv.cpp	(revision b002a55313fbd2e3af200f0ea77ccf0fbfd0885a)
@@ -0,0 +1,438 @@
+/*
+ * Copyright (C) 2017 The Android Open Source Project
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifdef __ANDROID__
+
+#include <ctype.h>
+#include <endian.h>
+#include <errno.h>
+#include <iconv.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <uchar.h>
+#include <wchar.h>
+
+__BEGIN_DECLS
+
+/*
+ * These return values are specified by POSIX for multibyte conversion
+ * functions.
+ */
+
+#ifdef __cplusplus
+#define __MB_ERR_ILLEGAL_SEQUENCE static_cast<size_t>(-1)
+#define __MB_ERR_INCOMPLETE_SEQUENCE static_cast<size_t>(-2)
+#else
+#define __MB_ERR_ILLEGAL_SEQUENCE (size_t)(-1)
+#define __MB_ERR_INCOMPLETE_SEQUENCE (size_t)(-2)
+#endif // __cplusplus
+#define __MB_IS_ERR(rv) (rv == __MB_ERR_ILLEGAL_SEQUENCE || \
+                         rv == __MB_ERR_INCOMPLETE_SEQUENCE)
+static inline __wur size_t mbstate_bytes_so_far(const mbstate_t* ps) {
+  return
+      (ps->__seq[2] != 0) ? 3 :
+      (ps->__seq[1] != 0) ? 2 :
+      (ps->__seq[0] != 0) ? 1 : 0;
+}
+static inline void mbstate_set_byte(mbstate_t* ps, int i, char byte) {
+  ps->__seq[i] = (uint8_t)(byte);
+}
+static inline __wur uint8_t mbstate_get_byte(const mbstate_t* ps, int n) {
+  return ps->__seq[n];
+}
+static inline __wur size_t mbstate_reset_and_return_illegal(int _errno, mbstate_t* ps) {
+  errno = _errno;
+#ifdef __cplusplus
+  *(reinterpret_cast<uint32_t*>(ps->__seq)) = 0;
+#else
+  *(uint32_t*)(ps->__seq) = 0;
+#endif // __cplusplus
+  return __MB_ERR_ILLEGAL_SEQUENCE;
+}
+static inline __wur size_t mbstate_reset_and_return(int _return, mbstate_t* ps) {
+#ifdef __cplusplus
+  *(reinterpret_cast<uint32_t*>(ps->__seq)) = 0;
+#else
+  *(uint32_t*)(ps->__seq) = 0;
+#endif // __cplusplus
+  return _return;
+}
+
+#ifdef __cplusplus
+# define INVALID_ICONV_T reinterpret_cast<iconv_t>(-1)
+#else // !__cplusplus
+# define INVALID_ICONV_T (iconv_t)(-1)
+#endif // __cplusplus
+
+// Ideally we'd use icu4c but the API mismatch seems too great. So we just offer something
+// equivalent to (but slightly easier to use for runs of text than) <uchar.h>. If you're
+// here to add more encodings, consider working on finishing the icu4c NDK wrappers instead.
+
+#ifdef __cplusplus
+ enum Encoding
+#else
+ typedef enum
+#endif // __cplusplus
+{
+  US_ASCII,
+  UTF_8,
+  UTF_16_LE,
+  UTF_16_BE,
+  UTF_32_LE,
+  UTF_32_BE,
+  WCHAR_T,
+#ifdef __cplusplus
+ };
+#else
+ } Encoding;
+#endif // __cplusplus
+
+#ifdef __cplusplus
+ enum Mode
+#else
+ typedef enum
+#endif // __cplusplus
+{
+  ERROR,
+  IGNORE,
+  TRANSLIT,
+#ifdef __cplusplus
+ };
+#else
+ } Mode;
+#endif // __cplusplus
+
+// This matching is strange but true.
+// See http://www.unicode.org/reports/tr22/#Charset_Alias_Matching.
+static bool __match_encoding(const char* lhs, const char* rhs) {
+  while (*lhs && *rhs) {
+    // Skip non-alnum in lhs; "UTF-8", "UTF_8", "UTF8", "UTF 8" are all equivalent.
+    // Also implement the "delete each 0 that is not preceded by a digit" rule.
+    for (; *lhs; ++lhs) {
+      if (isalnum(*lhs) && (*lhs != '0' || !isdigit(*(lhs + 1)))) break;
+    }
+    // Case doesn't matter either.
+    if (tolower(*lhs) != tolower(*rhs)) break;
+    ++lhs;
+    ++rhs;
+  }
+  // As a special case we treat the GNU "//" extensions as end of string.
+  if ((*lhs == '\0' || strstr(lhs, "//") == lhs) && *rhs == '\0') return true;
+  return false;
+}
+
+static bool __parse_encoding(const char* s, Encoding* encoding, Mode* mode) {
+  const char* suffix = strstr(s, "//");
+  if (suffix) {
+    if (!mode) return false;
+    if (strcmp(suffix, "//IGNORE") == 0) {
+      *mode = IGNORE;
+    } else if (strcmp(suffix, "//TRANSLIT") == 0) {
+      *mode = TRANSLIT;
+    } else {
+      return false;
+    }
+  }
+  if (__match_encoding(s, "utf8")) {
+    *encoding = UTF_8;
+  } else if (__match_encoding(s, "ascii") || __match_encoding(s, "usascii")) {
+    *encoding = US_ASCII;
+  } else if (__match_encoding(s, "utf16le")) {
+    *encoding = UTF_16_LE;
+  } else if (__match_encoding(s, "utf16be")) {
+    *encoding = UTF_16_BE;
+  } else if (__match_encoding(s, "utf32le")) {
+    *encoding = UTF_32_LE;
+  } else if (__match_encoding(s, "utf32be")) {
+    *encoding = UTF_32_BE;
+  } else if (__match_encoding(s, "wchart")) {
+    *encoding = WCHAR_T;
+  } else {
+    return false;
+  }
+  return true;
+}
+
+struct __iconv_t {
+  Encoding src_encoding;
+  Encoding dst_encoding;
+  Mode mode;
+/*
+  __iconv_t() : mode(ERROR) {
+  }
+*/
+  int Convert(char** src_buf0, size_t* src_bytes_left0, char** dst_buf0, size_t* dst_bytes_left0) {
+    // Reset state.
+    wc = 0;
+    memset(&ps, 0, sizeof(ps));
+    replacement_count = 0;
+    ignored = false;
+    src_buf = src_buf0;
+    src_bytes_left = src_bytes_left0;
+    dst_buf = dst_buf0;
+    dst_bytes_left = dst_bytes_left0;
+    while (*src_bytes_left > 0) {
+      if (!GetNext() || !Convert()) return -1;
+    }
+    return Done();
+  }
+ private:
+  char32_t wc;
+  char buf[16];
+  size_t src_bytes_used;
+  size_t dst_bytes_used;
+  mbstate_t ps;
+  size_t replacement_count;
+  bool ignored;
+  char** src_buf;
+  size_t* src_bytes_left;
+  char** dst_buf;
+  size_t* dst_bytes_left;
+  bool GetNext() {
+    errno = 0;
+    switch (src_encoding) {
+      case US_ASCII:
+        wc = **src_buf;
+        src_bytes_used = 1;
+        if (wc > 0x7f) errno = EILSEQ;
+        break;
+      case UTF_8:
+        src_bytes_used = mbrtoc32(&wc, *src_buf, *src_bytes_left, &ps);
+        if (src_bytes_used == __MB_ERR_ILLEGAL_SEQUENCE) {
+          break;  // EILSEQ already set.
+        } else if (src_bytes_used == __MB_ERR_INCOMPLETE_SEQUENCE) {
+          errno = EINVAL;
+          return false;
+        }
+        break;
+      case UTF_16_BE:
+      case UTF_16_LE: {
+        if (*src_bytes_left < 2) {
+          errno = EINVAL;
+          return false;
+        }
+        bool swap = (src_encoding == UTF_16_BE);
+        wc = In16(*src_buf, swap);
+        // 0xd800-0xdbff: high surrogates
+        // 0xdc00-0xdfff: low surrogates
+        if (wc >= 0xd800 && wc <= 0xdfff) {
+          if (wc >= 0xdc00) {  // Low surrogate before high surrogate.
+            errno = EILSEQ;
+            return false;
+          }
+          if (*src_bytes_left < 4) {
+            errno = EINVAL;
+            return false;
+          }
+          uint16_t hi = wc;
+          uint16_t lo = In16(*src_buf + 2, swap);
+          wc = 0x10000 + ((hi - 0xd800) << 10) + (lo - 0xdc00);
+          src_bytes_used = 4;
+        }
+        break;
+      }
+      case UTF_32_BE:
+      case UTF_32_LE:
+      case WCHAR_T:
+        if (*src_bytes_left < 4) {
+          errno = EINVAL;
+          return false;
+        }
+        wc = In32(*src_buf, (src_encoding == UTF_32_BE));
+        break;
+    }
+    if (errno == EILSEQ) {
+      switch (mode) {
+        case ERROR:
+          return false;
+        case IGNORE:
+          *src_buf += src_bytes_used;
+          *src_bytes_left -= src_bytes_used;
+          ignored = true;
+          return GetNext();
+        case TRANSLIT:
+          wc = '?';
+          ++replacement_count;
+          return true;
+      }
+    }
+    return true;
+  }
+
+  bool Convert() {
+    errno = 0;
+    switch (dst_encoding) {
+      case US_ASCII:
+        buf[0] = wc;
+        dst_bytes_used = 1;
+        if (wc > 0x7f) errno = EILSEQ;
+        break;
+      case UTF_8:
+        dst_bytes_used = c32rtomb(buf, wc, &ps);
+        if (dst_bytes_used == __MB_ERR_ILLEGAL_SEQUENCE) {
+          break;  // EILSEQ already set.
+        } else if (dst_bytes_used == __MB_ERR_INCOMPLETE_SEQUENCE) {
+          errno = EINVAL;
+          return false;
+        }
+        break;
+      case UTF_16_BE:
+      case UTF_16_LE: {
+        bool swap = (dst_encoding == UTF_16_BE);
+        if (wc < 0x10000) {  // BMP.
+          Out16(buf, wc, swap);
+        } else {  // Supplementary plane; output surrogate pair.
+          wc -= 0x10000;
+          char16_t hi = 0xd800 | (wc >> 10);
+          char16_t lo = 0xdc00 | (wc & 0x3ff);
+          Out16(buf + 0, hi, swap);
+          Out16(buf + 2, lo, swap);
+          dst_bytes_used = 4;
+        }
+      } break;
+      case UTF_32_BE:
+      case UTF_32_LE:
+      case WCHAR_T:
+        Out32(wc, (dst_encoding == UTF_32_BE));
+        break;
+    }
+    if (errno == EILSEQ) {
+      if (mode == IGNORE) {
+        *src_buf += src_bytes_used;
+        *src_bytes_left -= src_bytes_used;
+        ignored = true;
+        return true;
+      } else if (mode == TRANSLIT) {
+        wc = '?';
+        ++replacement_count;
+        return Convert();
+      }
+      return false;
+    }
+    return Emit();
+  }
+
+  uint16_t In16(const char* buf, bool swap) {
+#ifdef __cplusplus
+    const uint8_t* src = reinterpret_cast<const uint8_t*>(buf);
+#else // !__cplusplus
+    const uint8_t* src = (const uint8_t*)(buf);
+#endif // __cplusplus
+    uint16_t wc = (src[0]) | (src[1] << 8);
+    if (swap) wc = __swap16(wc);
+    src_bytes_used = 2;
+    return wc;
+  }
+
+  uint32_t In32(const char* buf, bool swap) {
+#ifdef __cplusplus
+    const uint8_t* src = reinterpret_cast<const uint8_t*>(buf);
+#else // !__cplusplus
+    const uint8_t* src = (const uint8_t*)(buf);
+#endif // __cplusplus
+    uint32_t wc = (src[0]) | (src[1] << 8) | (src[2] << 16) | (src[3] << 24);
+    if (swap) wc = __swap32(wc);
+    src_bytes_used = 4;
+    return wc;
+  }
+
+  void Out16(char* dst, char16_t ch, bool swap) {
+    if (swap) ch = __swap16(ch);
+    dst[0] = ch;
+    dst[1] = ch >> 8;
+    dst_bytes_used = 2;
+  }
+
+  void Out32(char32_t ch, bool swap) {
+    if (swap) ch = __swap32(ch);
+    buf[0] = ch;
+    buf[1] = ch >> 8;
+    buf[2] = ch >> 16;
+    buf[3] = ch >> 24;
+    dst_bytes_used = 4;
+  }
+
+  bool Emit() {
+    if (dst_bytes_used > *dst_bytes_left) {
+      errno = E2BIG;
+      return false;
+    }
+    memcpy(*dst_buf, buf, dst_bytes_used);
+    *src_buf += src_bytes_used;
+    *src_bytes_left -= src_bytes_used;
+    *dst_buf += dst_bytes_used;
+    *dst_bytes_left -= dst_bytes_used;
+    return true;
+  }
+
+  int Done() {
+    if (mode == TRANSLIT) return replacement_count;
+    if (ignored) {
+      errno = EILSEQ;
+      return -1;
+    }
+    return 0;
+  }
+};
+
+iconv_t iconv_open(const char* __dst_encoding, const char* __src_encoding) {
+  iconv_t result = iconv_t();
+  result->mode = ERROR;
+  if (!__parse_encoding(__src_encoding, &result->src_encoding, 0 /* nullptr */) ||
+      !__parse_encoding(__dst_encoding, &result->dst_encoding, &result->mode)) {
+    free(result);
+    errno = EINVAL;
+    return INVALID_ICONV_T;
+  }
+  return result;
+}
+
+size_t iconv(iconv_t __converter,
+             char** __src_buf, size_t* __src_bytes_left,
+             char** __dst_buf, size_t* __dst_bytes_left) {
+  if (__converter == INVALID_ICONV_T) {
+    errno = EBADF;
+    return -1;
+  }
+  return __converter->Convert(__src_buf, __src_bytes_left, __dst_buf, __dst_bytes_left);
+}
+
+int iconv_close(iconv_t __converter) {
+  if (__converter == INVALID_ICONV_T) {
+    errno = EBADF;
+    return -1;
+  }
+  free(__converter);
+  return 0;
+}
+
+__END_DECLS
+
+#endif // __ANDROID__
Index: src/java.base/unix/native/libjava/posix_spawn.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java.base/unix/native/libjava/posix_spawn.c b/src/java.base/unix/native/libjava/posix_spawn.c
new file mode 100644
--- /dev/null	(revision b002a55313fbd2e3af200f0ea77ccf0fbfd0885a)
+++ b/src/java.base/unix/native/libjava/posix_spawn.c	(revision b002a55313fbd2e3af200f0ea77ccf0fbfd0885a)
@@ -0,0 +1,147 @@
+// From https://android.googlesource.com/platform/external/dhcpcd-6.8.2/+/refs/heads/pie-dr1-release/compat/posix_spawn.c
+/*
+ * dhcpcd - DHCP client daemon
+ * Copyright (c) 2006-2012 Roy Marples <roy@marples.name>
+ * All rights reserved
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/* This implementation of posix_spawn is only suitable for the needs of dhcpcd
+ * but it could easily be extended to other applications. */
+
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <errno.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "posix_spawn.h"
+
+#ifndef _NSIG
+#ifdef _SIG_MAXSIG
+#define _NSIG _SIG_MAXSIG + 1
+#else
+/* Guess */
+#define _NSIG SIGPWR + 1
+#endif
+#endif
+
+extern char **environ;
+
+static int
+posix_spawnattr_handle(const posix_spawnattr_t *attrp)
+{
+  struct sigaction sa;
+  int i;
+  if (attrp->posix_attr_flags & POSIX_SPAWN_SETSIGMASK)
+    sigprocmask(SIG_SETMASK, &attrp->posix_attr_sigmask, NULL);
+  if (attrp->posix_attr_flags & POSIX_SPAWN_SETSIGDEF) {
+    memset(&sa, 0, sizeof(sa));
+    sa.sa_handler = SIG_DFL;
+    for (i = 1; i < _NSIG; i++) {
+      if (sigismember(&attrp->posix_attr_sigdefault, i)) {
+        if (sigaction(i, &sa, NULL) == -1)
+          return -1;
+      }
+    }
+  }
+  return 0;
+}
+
+inline static int
+is_vfork_safe(short int flags)
+{
+  return !(flags & (POSIX_SPAWN_SETSIGDEF | POSIX_SPAWN_SETSIGMASK));
+}
+
+int
+posix_spawn(pid_t *pid, const char *path,
+  const posix_spawn_file_actions_t *file_actions,
+  const posix_spawnattr_t *attrp,
+  char *const argv[], char *const envp[])
+{
+  short int flags;
+  pid_t p;
+  volatile int error;
+  error = 0;
+  flags = attrp ? attrp->posix_attr_flags : 0;
+  if (file_actions == NULL && is_vfork_safe(flags))
+    p = vfork();
+  else
+#ifdef THERE_IS_NO_FORK
+    return ENOSYS;
+#else
+    p = fork();
+#endif
+  switch (p) {
+  case -1:
+    return errno;
+  case 0:
+    if (attrp) {
+      error = posix_spawnattr_handle(attrp);
+      if (error)
+        _exit(127);
+    }
+    execve(path, argv, envp);
+    error = errno;
+    _exit(127);
+  default:
+    if (error != 0)
+      waitpid(p, NULL, WNOHANG);
+    else if (pid != NULL)
+      *pid = p;
+    return error;
+  }
+}
+
+int
+posix_spawnattr_init(posix_spawnattr_t *attr)
+{
+  memset(attr, 0, sizeof(*attr));
+  attr->posix_attr_flags = 0;
+  sigprocmask(0, NULL, &attr->posix_attr_sigmask);
+  sigemptyset(&attr->posix_attr_sigdefault);
+  return 0;
+}
+
+int
+posix_spawnattr_setflags(posix_spawnattr_t *attr, short flags)
+{
+  attr->posix_attr_flags = flags;
+  return 0;
+}
+
+int
+posix_spawnattr_setsigmask(posix_spawnattr_t *attr, const sigset_t *sigmask)
+{
+  attr->posix_attr_sigmask = *sigmask;
+  return 0;
+}
+
+int
+posix_spawnattr_setsigdefault(posix_spawnattr_t *attr, const sigset_t *sigmask)
+{
+  attr->posix_attr_sigdefault = *sigmask;
+  return 0;
+}
Index: src/java.base/unix/native/libjava/posix_spawn.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/java.base/unix/native/libjava/posix_spawn.h b/src/java.base/unix/native/libjava/posix_spawn.h
new file mode 100644
--- /dev/null	(revision b002a55313fbd2e3af200f0ea77ccf0fbfd0885a)
+++ b/src/java.base/unix/native/libjava/posix_spawn.h	(revision b002a55313fbd2e3af200f0ea77ccf0fbfd0885a)
@@ -0,0 +1,53 @@
+// From https://android.googlesource.com/platform/external/dhcpcd-6.8.2/+/refs/heads/pie-dr1-release/compat/posix_spawn.h
+/*
+ * dhcpcd - DHCP client daemon
+ * Copyright (c) 2006-2012 Roy Marples <roy@marples.name>
+ * All rights reserved
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef POSIX_SPAWN_H
+#define POSIX_SPAWN_H
+
+#include <signal.h>
+
+typedef struct {
+    short posix_attr_flags;
+#define POSIX_SPAWN_SETSIGDEF       0x10
+#define POSIX_SPAWN_SETSIGMASK      0x20
+    sigset_t posix_attr_sigmask;
+    sigset_t posix_attr_sigdefault;
+} posix_spawnattr_t;
+
+typedef struct {
+//  int unused;
+} posix_spawn_file_actions_t;
+
+int posix_spawn(pid_t *, const char *,
+    const posix_spawn_file_actions_t *, const posix_spawnattr_t *,
+    char *const [], char *const []);
+int posix_spawnattr_init(posix_spawnattr_t *);
+int posix_spawnattr_setflags(posix_spawnattr_t *, short);
+int posix_spawnattr_setsigmask(posix_spawnattr_t *, const sigset_t *);
+int posix_spawnattr_setsigdefault(posix_spawnattr_t *, const sigset_t *);
+
+#endif
diff --git a/src/java.base/share/classes/sun/launcher/resources/launcher.properties b/src/java.base/share/classes/sun/launcher/resources/launcher.properties
deleted file mode 100644
index 9960b026d11f7b97bcc4bc0b3283248fe013bda0..0000000000000000000000000000000000000000
GIT binary patch
literal 0
Hc$@<O00001

